/*  _eval_stub_libs.c -- Wrapper that includes all chibi-ffi generated .c files
 *
 *  Each stub-generated .c file defines sexp_init_library().
 *  We rename each via #define before including so they can coexist
 *  in a single binary.
 *
 *  Generated by: eval.exe chibi-scheme/tools/chibi-ffi <file>.stub
 */

#include <chibi/eval.h>

/* ====================================================================
 * Windows compatibility shims for POSIX APIs used by generated stubs.
 * _chibi_win_compat.h (via sexp.h) already provides:
 *   fcntl, F_GETFL, F_SETFL, O_NONBLOCK, gettimeofday, struct timezone
 * We add the remaining symbols needed by net.c and time.c here.
 * ==================================================================== */
#ifdef _WIN32

#include <time.h>    /* struct tm, localtime_s, asctime_s, ctime_s, mktime */

/* ---- Networking compat (for chibi/net.c) ---- */

#include <BaseTsd.h>
#ifndef _SSIZE_T_DEFINED
typedef SSIZE_T ssize_t;
#define _SSIZE_T_DEFINED
#endif

#ifndef EWOULDBLOCK
#define EWOULDBLOCK WSAEWOULDBLOCK
#endif

#ifndef AF_UNIX
#define AF_UNIX 1
#endif

/* socketpair: not available on Windows, stub returns error */
static int eval_socketpair(int domain, int type, int protocol, int sv[2]) {
    (void)domain; (void)type; (void)protocol; (void)sv;
    return -1;
}
#define socketpair eval_socketpair

/* ---- Time compat (for chibi/time.c) ---- */

/* settimeofday: privileged on Windows, stub returns error */
static int eval_settimeofday(const struct timeval *tv, const struct timezone *tz) {
    (void)tv; (void)tz;
    return -1;
}
#define settimeofday eval_settimeofday

/*
 * Windows struct tm lacks the BSD/GNU extensions tm_zone and tm_gmtoff.
 * The stub-generated time.c accesses these via ((struct tm*)ptr)->tm_zone.
 * Strategy: define eval_tm with the extra fields, then #define tm eval_tm
 * around the time.c include so sizeof/field access use the extended struct.
 * Wrapper functions bridge between eval_tm and system struct tm.
 *
 * Note: #define tm eval_tm only affects the C token "tm" when it appears
 * as a standalone identifier, NOT as part of tm_sec, tm_zone, etc.
 */
struct eval_tm {
    int tm_sec, tm_min, tm_hour, tm_mday, tm_mon, tm_year;
    int tm_wday, tm_yday, tm_isdst;
    long tm_gmtoff;
    const char *tm_zone;
};

static struct eval_tm* eval_localtime_r(const time_t *timep, struct eval_tm *result) {
    struct tm sys_tm;
    if (localtime_s(&sys_tm, timep) != 0) return NULL;
    result->tm_sec   = sys_tm.tm_sec;
    result->tm_min   = sys_tm.tm_min;
    result->tm_hour  = sys_tm.tm_hour;
    result->tm_mday  = sys_tm.tm_mday;
    result->tm_mon   = sys_tm.tm_mon;
    result->tm_year  = sys_tm.tm_year;
    result->tm_wday  = sys_tm.tm_wday;
    result->tm_yday  = sys_tm.tm_yday;
    result->tm_isdst = sys_tm.tm_isdst;
    /* Compute BSD/GNU extensions */
    {
        TIME_ZONE_INFORMATION tzi;
        DWORD r = GetTimeZoneInformation(&tzi);
        static char _eval_tz_name[64];
        result->tm_gmtoff = -(tzi.Bias * 60L);
        if (sys_tm.tm_isdst > 0 && r == TIME_ZONE_ID_DAYLIGHT)
            result->tm_gmtoff -= tzi.DaylightBias * 60L;
        WideCharToMultiByte(CP_UTF8, 0,
            (sys_tm.tm_isdst > 0) ? tzi.DaylightName : tzi.StandardName,
            -1, _eval_tz_name, sizeof(_eval_tz_name), NULL, NULL);
        result->tm_zone = _eval_tz_name;
    }
    return result;
}

static char* eval_asctime_r(const struct eval_tm *etm, char *buf) {
    struct tm st = {0};
    st.tm_sec = etm->tm_sec; st.tm_min = etm->tm_min;
    st.tm_hour = etm->tm_hour; st.tm_mday = etm->tm_mday;
    st.tm_mon = etm->tm_mon; st.tm_year = etm->tm_year;
    st.tm_wday = etm->tm_wday; st.tm_yday = etm->tm_yday;
    st.tm_isdst = etm->tm_isdst;
    return (asctime_s(buf, 64, &st) == 0) ? buf : NULL;
}

static char* eval_ctime_r(const time_t *timep, char *buf) {
    return (ctime_s(buf, 64, timep) == 0) ? buf : NULL;
}

static time_t eval_mktime(struct eval_tm *etm) {
    struct tm st = {0};
    st.tm_sec = etm->tm_sec; st.tm_min = etm->tm_min;
    st.tm_hour = etm->tm_hour; st.tm_mday = etm->tm_mday;
    st.tm_mon = etm->tm_mon; st.tm_year = etm->tm_year;
    st.tm_isdst = etm->tm_isdst;
    return mktime(&st);
}

#endif /* _WIN32 */


/* ---- Windows close() wrapper for sockets ---- */
/* The filesystem stub maps close-file-descriptor to C close().
 * On Windows, close()/_close() only works for CRT file descriptors,
 * NOT for Winsock sockets.  We try closesocket() first; if it fails
 * with WSAENOTSOCK the fd is a regular CRT fd and we fall back to _close(). */
#ifdef _WIN32
static int eval_close(int fd) {
    int ret = closesocket((SOCKET)(intptr_t)fd);
    if (ret == SOCKET_ERROR && WSAGetLastError() == WSAENOTSOCK)
        ret = _close(fd);
    return ret;
}
#define close eval_close
#endif

/* ---- chibi/filesystem ---- */
#define sexp_init_library sexp_init_chibi_filesystem
#include "../chibi-scheme/lib/chibi/filesystem.c"
#undef sexp_init_library

#ifdef _WIN32
#undef close
#endif

/* ---- chibi/io ---- */
#define sexp_init_library sexp_init_chibi_io
#include "../chibi-scheme/lib/chibi/io/io.c"
#undef sexp_init_library

/* ---- chibi/net ---- */
#define sexp_init_library sexp_init_chibi_net
#include "../chibi-scheme/lib/chibi/net.c"
#undef sexp_init_library

/* ---- chibi/time (stub version) ---- */
/* On Windows, redirect struct tm â†’ eval_tm and POSIX _r functions
 * to our wrappers so tm_zone/tm_gmtoff fields are available. */
#ifdef _WIN32
#define tm        eval_tm
#define localtime_r eval_localtime_r
#define asctime_r   eval_asctime_r
#define ctime_r     eval_ctime_r
#define mktime      eval_mktime
#endif

#define sexp_init_library sexp_init_chibi_time
#include "../chibi-scheme/lib/chibi/time.c"
#undef sexp_init_library

#ifdef _WIN32
#undef tm
#undef localtime_r
#undef asctime_r
#undef ctime_r
#undef mktime
#endif

/* ---- chibi/crypto ---- */
#define sexp_init_library sexp_init_chibi_crypto
#include "../chibi-scheme/lib/chibi/crypto/crypto.c"
#undef sexp_init_library

/* ---- scheme/bytevector ---- */
#define sexp_init_library sexp_init_scheme_bytevector
#include "../chibi-scheme/lib/scheme/bytevector.c"
#undef sexp_init_library

/* ---- chibi/win32/process-win32 ---- */
#ifdef _WIN32
#define sexp_init_library sexp_init_chibi_win32_process
#include "../chibi-scheme/lib/chibi/win32/process-win32.c"
#undef sexp_init_library
#endif

/* ---- srfi/144/math ---- */
#define sexp_init_library sexp_init_srfi144_math
#include "../chibi-scheme/lib/srfi/144/math.c"
#undef sexp_init_library

/* ---- srfi/160/uvprims ---- */
#define sexp_init_library sexp_init_srfi160_uvprims
#include "../chibi-scheme/lib/srfi/160/uvprims.c"
#undef sexp_init_library
