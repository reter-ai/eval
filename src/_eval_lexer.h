/*  _eval_lexer.h -- Eval language tokenizer  */

#ifndef EVAL_LEXER_H
#define EVAL_LEXER_H

#include <stddef.h>

/* All token values are defined by the Lemon-generated eval_grammar.h. */
#include "eval_grammar.h"

/* TOK_EOF = 0: Lemon convention for end-of-input (not generated by lemon) */
#define TOK_EOF 0

/* TOK_COUNT: one past the highest token value (for debug name arrays etc.) */
/* Must be > highest token value. TOK_RECEIVE is currently the highest. */
#define TOK_COUNT (TOK_RECEIVE + 1)

/* Token structure */
typedef struct {
    int type;
    const char *start;
    int length;
    int line;
    int col;
    union {
        long long int_val;
        double float_val;
    } value;
} EvalToken;

/* F-string nesting limit */
#define FSTR_MAX_NESTING 8

/* Lexer state */
typedef struct {
    const char *source;
    const char *current;
    int line;
    int col;
    char *error_msg;
    int has_error;
    int prev_ends_expr; /* true if previous token can end an expression */
    int prev_token_type; /* type of the previous token */
    int fstr_mode;      /* 0=normal, 1=text(first), 2=text(mid), 3=expr */
    int fstr_nesting;   /* current nesting depth (0 = not in fstring) */
    int fstr_brace_stack[FSTR_MAX_NESTING]; /* brace depth per nesting level */
} EvalLexer;

/* Initialize the lexer with source code */
void eval_lexer_init(EvalLexer *lexer, const char *source);

/* Get the next token. Returns 0 on success, -1 on error. */
int eval_lexer_next(EvalLexer *lexer, EvalToken *token);

/* Free any error message */
void eval_lexer_free(EvalLexer *lexer);

/* Get token type name for debugging */
const char *eval_token_name(int type);

#endif /* EVAL_LEXER_H */
