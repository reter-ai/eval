// http_server.eval â€” Concurrent HTTP server with green threads
//
// Demonstrates: Signal, Computed, Effect, batch, green threads, nonblocking I/O
//
// This example uses the low-level socket API for full control over routing,
// reactive state, and shutdown logic. For simpler servers, use the built-in
// TcpServer OO wrapper:
//
//   define server = TcpServer(8080, function(sock, addr, port) {
//       define data = sock->recv(4096);
//       sock->send("HTTP/1.0 200 OK\r\nContent-Length: 2\r\n\r\nOK");
//   });
//   server->run();
//
// Usage:
//   eval examples/http_server.eval
//   Then visit http://localhost:8080/ in a browser
//   GET /shutdown to stop the server

// ===== Helpers =====

define tcp_send = function(sock, str) {
    send(sock, string_to_utf8(str));
};

define tcp_recv = function(sock, n) {
    define bv = recv(sock, n);
    if(bv == false) "" else utf8_to_string(bv);
};

// ===== Reactive State =====

define request_count = Signal(0);
define active_conns = Signal(0);
define last_path = Signal("");
define last_method = Signal("");
define error_count = Signal(0);

define stats = Computed(function() {
    [request_count(), active_conns(), error_count(),
     last_method(), last_path()];
});

Effect(function() {
    define s = stats();
    define count = s->first;
    when(count > 0) {
        display("[server] Requests: " ++ `number->string`(count)
            ++ "  Active: " ++ `number->string`(s->ref(1))
            ++ "  Errors: " ++ `number->string`(s->ref(2))
            ++ "  Last: " ++ s->ref(3)
            ++ " " ++ s->ref(4));
        newline();
    };
});

// ===== HTTP Parsing =====

define parse_request = function(data) {
    define header_end = data->index_of("\r\n\r\n");
    define headers_str = if(header_end) data->slice(0, header_end) else data;
    define body = if(header_end) data->slice(header_end + 4, data->length) else "";

    define first_line_end = headers_str->index_of("\r\n");
    define request_line = if(first_line_end) headers_str->slice(0, first_line_end) else headers_str;

    define sp1 = request_line->index_of(" ");
    define method = if(sp1) request_line->slice(0, sp1) else "GET";
    define rest = if(sp1) request_line->slice(sp1 + 1, request_line->length) else "/";
    define sp2 = rest->index_of(" ");
    define path = if(sp2) rest->slice(0, sp2) else rest;

    [method, path, body];
};

define send_response = function(sock, status, content_type, body) {
    define status_text = cond(
        status == 200: "OK",
        status == 404: "Not Found",
        status == 405: "Method Not Allowed",
        status == 500: "Internal Server Error",
        else: "Unknown"
    );
    define response = "HTTP/1.0 " ++ `number->string`(status) ++ " " ++ status_text ++ "\r\n"
        ++ "Content-Type: " ++ content_type ++ "\r\n"
        ++ "Content-Length: " ++ `number->string`(body->length) ++ "\r\n"
        ++ "Connection: close\r\n"
        ++ "\r\n"
        ++ body;
    tcp_send(sock, response);
};

// ===== Route Handlers =====

define handle_index = function(method, path, body) {
    [200, "text/plain", "Welcome to Eval HTTP Server\n"];
};

define handle_count = function(method, path, body) {
    [200, "text/plain", `number->string`(request_count())];
};

define handle_stats = function(method, path, body) {
    define s = stats();
    define json = "{\"requests\":" ++ `number->string`(s->first)
        ++ ",\"active\":" ++ `number->string`(s->ref(1))
        ++ ",\"errors\":" ++ `number->string`(s->ref(2))
        ++ ",\"last_method\":\"" ++ s->ref(3)
        ++ "\",\"last_path\":\"" ++ s->ref(4)
        ++ "\"}";
    [200, "application/json", json];
};

define handle_echo = function(method, path, body) {
    if(method == "POST") [200, "text/plain", body]
    else [405, "text/plain", "Method Not Allowed\n"];
};

// Route table: [method-or-false, path, handler]
define routes = [
    ["GET",  "/",          handle_index],
    ["GET",  "/api/count", handle_count],
    ["GET",  "/api/stats", handle_stats],
    [false,  "/api/echo",  handle_echo]
];

define find_route = function(method, path) {
    define match = routes->find(function(route)
        (route->first == false || route->first == method) && route->ref(1) == path);
    if(match) match->ref(2) else false;
};

// ===== Connection handler (runs in its own green thread) =====

define handle_connection = function(conn) {
    active_conns->update(function(n) n + 1);

    try {
        define data = tcp_recv(conn, 8192);
        define parsed = parse_request(data);
        define method = parsed->first;
        define path = parsed->ref(1);
        define body = parsed->ref(2);

        // Check for shutdown
        if(method == "GET" && path == "/shutdown") {
            send_response(conn, 200, "text/plain", "Shutting down\n");
            close_file_descriptor(conn);
            running->set(false);
        } else {
            define handler = find_route(method, path);
            define response = if(handler != false) {
                try handler(method, path, body)
                catch(err) {
                    error_count->update(function(n) n + 1);
                    [500, "text/plain", "Internal Server Error\n"];
                };
            } else [404, "text/plain", "Not Found\n"];

            define status = response->first;
            define ctype = response->ref(1);
            define rbody = response->ref(2);

            send_response(conn, status, ctype, rbody);
            close_file_descriptor(conn);

            batch(function() {
                request_count->update(function(n) n + 1);
                last_method->set(method);
                last_path->set(path);
            });
        };
    } catch(err) {
        error_count->update(function(n) n + 1);
        try close_file_descriptor(conn) catch(e) false;
    };

    active_conns->update(function(n) n - 1);
};

// ===== Accept loop =====

define port = 8080;
define running = Signal(true);

define ai = get_address_info("0.0.0.0", `number->string`(port));
define listener = make_listener_socket(ai);
display("[server] Listening on port " ++ `number->string`(port));
newline();

// Main loop: accept is nonblocking (yields to green thread scheduler).
// Each connection is dispatched to a green thread immediately.
while(running()) {
    define sa = make_sockaddr();
    define conn = accept(listener, sa, 16);
    thread_start(make_thread(function() handle_connection(conn)));
};

close_file_descriptor(listener);
display("[server] Stopped.");
newline();
