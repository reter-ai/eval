// http_server.eval — Concurrent HTTP server with green threads
//
// Demonstrates: Signal, Computed, Effect, batch, green threads, nonblocking I/O
//
// Each incoming connection is handled in its own green thread,
// so the server can accept new connections while others are being served.
// accept/send/recv are nonblocking — they yield to the scheduler on WOULDBLOCK.
//
// Usage:
//   eval examples/http_server.eval
//   Then visit http://localhost:8080/ in a browser
//   GET /shutdown to stop the server

// ===== Helpers =====

// Find needle in str, return integer index or false.
// (string_contains returns a cursor; this converts to int for substring use.)
define string_index = function(str, needle) {
    define cur = string_contains(str, needle);
    if(cur) `string-cursor->index`(str, cur) else false;
};

define tcp_send = function(sock, str) {
    send(sock, string_to_utf8(str));
};

define tcp_recv = function(sock, n) {
    define bv = recv(sock, n);
    if(bv == false) "" else utf8_to_string(bv);
};

// ===== Reactive State =====

define request_count = Signal(0);
define active_conns = Signal(0);
define last_path = Signal("");
define last_method = Signal("");
define error_count = Signal(0);

define stats = Computed(function() {
    [request_count(), active_conns(), error_count(),
     last_method(), last_path()];
});

Effect(function() {
    define s = stats();
    define count = car(s);
    when(count > 0) {
        display("[server] Requests: " ++ `number->string`(count)
            ++ "  Active: " ++ `number->string`(car(cdr(s)))
            ++ "  Errors: " ++ `number->string`(car(cdr(cdr(s))))
            ++ "  Last: " ++ car(cdr(cdr(cdr(s))))
            ++ " " ++ car(cdr(cdr(cdr(cdr(s))))));
        newline();
    };
});

// ===== HTTP Parsing =====

define parse_request = function(data) {
    define header_end = string_index(data, "\r\n\r\n");
    define headers_str = if(header_end) substring(data, 0, header_end) else data;
    define body = if(header_end) substring(data, header_end + 4, `string-length`(data)) else "";

    define first_line_end = string_index(headers_str, "\r\n");
    define request_line = if(first_line_end) substring(headers_str, 0, first_line_end) else headers_str;

    define sp1 = string_index(request_line, " ");
    define method = if(sp1) substring(request_line, 0, sp1) else "GET";
    define rest = if(sp1) substring(request_line, sp1 + 1, `string-length`(request_line)) else "/";
    define sp2 = string_index(rest, " ");
    define path = if(sp2) substring(rest, 0, sp2) else rest;

    [method, path, body];
};

define send_response = function(sock, status, content_type, body) {
    define status_text = cond(
        status == 200: "OK",
        status == 404: "Not Found",
        status == 405: "Method Not Allowed",
        status == 500: "Internal Server Error",
        else: "Unknown"
    );
    define response = "HTTP/1.0 " ++ `number->string`(status) ++ " " ++ status_text ++ "\r\n"
        ++ "Content-Type: " ++ content_type ++ "\r\n"
        ++ "Content-Length: " ++ `number->string`(`string-length`(body)) ++ "\r\n"
        ++ "Connection: close\r\n"
        ++ "\r\n"
        ++ body;
    tcp_send(sock, response);
};

// ===== Route Handlers =====

define handle_index = function(method, path, body) {
    [200, "text/plain", "Welcome to Eval HTTP Server\n"];
};

define handle_count = function(method, path, body) {
    [200, "text/plain", `number->string`(request_count())];
};

define handle_stats = function(method, path, body) {
    define s = stats();
    define json = "{\"requests\":" ++ `number->string`(car(s))
        ++ ",\"active\":" ++ `number->string`(car(cdr(s)))
        ++ ",\"errors\":" ++ `number->string`(car(cdr(cdr(s))))
        ++ ",\"last_method\":\"" ++ car(cdr(cdr(cdr(s))))
        ++ "\",\"last_path\":\"" ++ car(cdr(cdr(cdr(cdr(s)))))
        ++ "\"}";
    [200, "application/json", json];
};

define handle_echo = function(method, path, body) {
    if(method == "POST") [200, "text/plain", body]
    else [405, "text/plain", "Method Not Allowed\n"];
};

// Route table: [method-or-false, path, handler]
define routes = [
    ["GET",  "/",          handle_index],
    ["GET",  "/api/count", handle_count],
    ["GET",  "/api/stats", handle_stats],
    [false,  "/api/echo",  handle_echo]
];

define find_route = function(method, path) {
    define result = false;
    define r = routes;
    while(r != []) {
        define route = car(r);
        define route_method = car(route);
        define route_path = car(cdr(route));
        when((route_method == false || route_method == method) && route_path == path) {
            result = car(cdr(cdr(route)));
        };
        r = cdr(r);
    };
    result;
};

// ===== Connection handler (runs in its own green thread) =====

define handle_connection = function(conn) {
    active_conns->update(function(n) n + 1);

    try {
        define data = tcp_recv(conn, 8192);
        define parsed = parse_request(data);
        define method = car(parsed);
        define path = car(cdr(parsed));
        define body = car(cdr(cdr(parsed)));

        // Check for shutdown
        if(method == "GET" && path == "/shutdown") {
            send_response(conn, 200, "text/plain", "Shutting down\n");
            close_file_descriptor(conn);
            running->set(false);
        } else {
            define handler = find_route(method, path);
            define response = if(handler != false) {
                try handler(method, path, body)
                catch(err) {
                    error_count->update(function(n) n + 1);
                    [500, "text/plain", "Internal Server Error\n"];
                };
            } else [404, "text/plain", "Not Found\n"];

            define status = car(response);
            define ctype = car(cdr(response));
            define rbody = car(cdr(cdr(response)));

            send_response(conn, status, ctype, rbody);
            close_file_descriptor(conn);

            batch(function() {
                request_count->update(function(n) n + 1);
                last_method->set(method);
                last_path->set(path);
            });
        };
    } catch(err) {
        error_count->update(function(n) n + 1);
        try close_file_descriptor(conn) catch(e) false;
    };

    active_conns->update(function(n) n - 1);
};

// ===== Accept loop =====

define port = 8080;
define running = Signal(true);

define ai = get_address_info("0.0.0.0", `number->string`(port));
define listener = make_listener_socket(ai);
display("[server] Listening on port " ++ `number->string`(port));
newline();

// Main loop: accept is nonblocking (yields to green thread scheduler).
// Each connection is dispatched to a green thread immediately.
while(running()) {
    define sa = make_sockaddr();
    define conn = accept(listener, sa, 16);
    thread_start(make_thread(function() handle_connection(conn)));
};

close_file_descriptor(listener);
display("[server] Stopped.");
newline();
