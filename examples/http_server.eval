// http_server.eval — Concurrent HTTP server with hybrid async
//
// Demonstrates: Signal, Computed, Effect, batch, green threads, nonblocking I/O,
//               AsyncPool, parallel async (OS threads for CPU work)
//
// Architecture:
//   AsyncPool(4) provides OS thread pool for `parallel async`
//   Accept loop runs on green thread scheduler
//   Per-connection green threads handle I/O
//   CPU-heavy routes offload to OS threads via `parallel async`
//
// Routes:
//   GET  /              — static welcome page
//   GET  /api/count     — request count
//   GET  /api/stats     — JSON stats (compute vs I/O counts)
//   GET  /api/fib?n=N   — fibonacci (CPU on OS thread)
//   POST /api/transform — uppercase text (CPU on OS thread)
//   POST /api/echo      — echo body
//   GET  /shutdown      — stop the server
//
// Usage:
//   eval examples/http_server.eval
//   Then visit http://localhost:8080/ in a browser

// ===== Helpers =====

define tcp_send = function(sock, str) {
    send(sock, string_to_utf8(str));
};

define tcp_recv = function(sock, n) {
    define bv = recv(sock, n);
    if(bv == false) "" else utf8_to_string(bv);
};

// ===== Reactive State =====

define request_count = Signal(0);
define active_conns = Signal(0);
define last_path = Signal("");
define last_method = Signal("");
define error_count = Signal(0);
define io_count = Signal(0);
define compute_count = Signal(0);

define stats = Computed(function() {
    [request_count(), active_conns(), error_count(),
     last_method(), last_path(),
     io_count(), compute_count()];
});

Effect(function() {
    define s = stats();
    define count = s->first;
    when(count > 0) {
        display("[server] Requests: " ++ `number->string`(count)
            ++ "  Active: " ++ `number->string`(s->ref(1))
            ++ "  Errors: " ++ `number->string`(s->ref(2))
            ++ "  I/O: " ++ `number->string`(s->ref(5))
            ++ "  Compute: " ++ `number->string`(s->ref(6))
            ++ "  Last: " ++ s->ref(3)
            ++ " " ++ s->ref(4));
        newline();
    };
});

// ===== HTTP Parsing =====

define parse_request = function(data) {
    define header_end = data->index_of("\r\n\r\n");
    define headers_str = if(header_end) data->slice(0, header_end) else data;
    define body = if(header_end) data->slice(header_end + 4, data->length) else "";

    define first_line_end = headers_str->index_of("\r\n");
    define request_line = if(first_line_end) headers_str->slice(0, first_line_end) else headers_str;

    define sp1 = request_line->index_of(" ");
    define method = if(sp1) request_line->slice(0, sp1) else "GET";
    define rest = if(sp1) request_line->slice(sp1 + 1, request_line->length) else "/";
    define sp2 = rest->index_of(" ");
    define path = if(sp2) rest->slice(0, sp2) else rest;

    [method, path, body];
};

define send_response = function(sock, status, content_type, body) {
    define status_text = cond(
        status == 200: "OK",
        status == 404: "Not Found",
        status == 405: "Method Not Allowed",
        status == 500: "Internal Server Error",
        else: "Unknown"
    );
    define response = "HTTP/1.0 " ++ `number->string`(status) ++ " " ++ status_text ++ "\r\n"
        ++ "Content-Type: " ++ content_type ++ "\r\n"
        ++ "Content-Length: " ++ `number->string`(body->length) ++ "\r\n"
        ++ "Connection: close\r\n"
        ++ "\r\n"
        ++ body;
    tcp_send(sock, response);
};

// ===== Route Handlers =====

define handle_index = function(method, path, body) {
    [200, "text/plain", "Welcome to Eval HTTP Server (hybrid async)\n"];
};

define handle_count = function(method, path, body) {
    [200, "text/plain", `number->string`(request_count())];
};

define handle_stats = function(method, path, body) {
    define s = stats();
    define json = "{\"requests\":" ++ `number->string`(s->first)
        ++ ",\"active\":" ++ `number->string`(s->ref(1))
        ++ ",\"errors\":" ++ `number->string`(s->ref(2))
        ++ ",\"io\":" ++ `number->string`(s->ref(5))
        ++ ",\"compute\":" ++ `number->string`(s->ref(6))
        ++ ",\"last_method\":\"" ++ s->ref(3)
        ++ "\",\"last_path\":\"" ++ s->ref(4)
        ++ "\"}";
    [200, "application/json", json];
};

define handle_echo = function(method, path, body) {
    if(method == "POST") [200, "text/plain", body]
    else [405, "text/plain", "Method Not Allowed\n"];
};

// CPU-heavy: fibonacci on OS thread via parallel async
define handle_fib = function(method, path, body) {
    // Parse n from query string: /api/fib?n=30
    define eq_idx = path->index_of("=");
    define n = if(eq_idx) (path->slice(eq_idx + 1, path->length))->to_number() else 10;

    // Offload CPU work to OS thread, green thread yields to accept loop
    define result = await(parallel async {
        define fib = function(n) if(n <= 1) n else fib(n - 1) + fib(n - 2);
        fib(n);
    });

    compute_count->update(function(c) c + 1);
    [200, "text/plain", `number->string`(result)];
};

// CPU-heavy: uppercase transform on OS thread via parallel async
define handle_transform = function(method, path, body) {
    if(method != "POST") return [405, "text/plain", "Method Not Allowed\n"];

    define text = body;
    // Offload string processing to OS thread
    define result = await(parallel async {
        text->upper() ++ " [transformed on OS thread]";
    });

    compute_count->update(function(c) c + 1);
    [200, "text/plain", result];
};

// Route table: [method-or-false, path-prefix, handler, prefix-match?]
define routes = [
    ["GET",  "/",              handle_index,     false],
    ["GET",  "/api/count",     handle_count,     false],
    ["GET",  "/api/stats",     handle_stats,     false],
    ["GET",  "/api/fib",       handle_fib,       true],
    [false,  "/api/transform", handle_transform, true],
    [false,  "/api/echo",      handle_echo,      false]
];

define find_route = function(method, path) {
    define match = routes->find(function(route) {
        define method_ok = route->first == false || route->first == method;
        define path_ok = if(route->ref(3))
            path->starts_with(route->ref(1))
        else
            route->ref(1) == path;
        method_ok && path_ok;
    });
    if(match) match->ref(2) else false;
};

// ===== Connection handler (runs in its own green thread) =====

define handle_connection = function(conn) {
    active_conns->update(function(n) n + 1);

    try {
        define data = tcp_recv(conn, 8192);
        define parsed = parse_request(data);
        define method = parsed->first;
        define path = parsed->ref(1);
        define body = parsed->ref(2);

        // Check for shutdown
        if(method == "GET" && path == "/shutdown") {
            send_response(conn, 200, "text/plain", "Shutting down\n");
            close_file_descriptor(conn);
            running->set(false);
        } else {
            define handler = find_route(method, path);
            define is_compute = path->starts_with("/api/fib") || path->starts_with("/api/transform");
            define response = if(handler != false) {
                try handler(method, path, body)
                catch(err) {
                    error_count->update(function(n) n + 1);
                    [500, "text/plain", "Internal Server Error\n"];
                };
            } else [404, "text/plain", "Not Found\n"];

            define status = response->first;
            define ctype = response->ref(1);
            define rbody = response->ref(2);

            send_response(conn, status, ctype, rbody);
            close_file_descriptor(conn);

            batch(function() {
                request_count->update(function(n) n + 1);
                last_method->set(method);
                last_path->set(path);
                unless(is_compute)
                    io_count->update(function(n) n + 1);
            });
        };
    } catch(err) {
        error_count->update(function(n) n + 1);
        try close_file_descriptor(conn) catch(e) false;
    };

    active_conns->update(function(n) n - 1);
};

// ===== Accept loop (wrapped in AsyncPool for parallel async support) =====

define port = 8080;
define running = Signal(true);

with(ap = AsyncPool(4)) {
    define ai = get_address_info("0.0.0.0", `number->string`(port));
    define listener = make_listener_socket(ai);
    display("[server] Listening on port " ++ `number->string`(port) ++ " (4 OS threads for compute)");
    newline();

    // Main loop: accept is nonblocking (yields to green thread scheduler).
    // Each connection is dispatched to a green thread immediately.
    // CPU-heavy route handlers use `parallel async` to offload to OS threads.
    while(running()) {
        define sa = make_sockaddr();
        define conn = accept(listener, sa, 16);
        thread_start(make_thread(function() handle_connection(conn)));
    };

    close_file_descriptor(listener);
};

display("[server] Stopped.");
newline();
