// file_processor.eval — Reactive File Processing Pipeline
//
// Demonstrates: Signal, Computed, Effect, batch, watch,
//               filesystem operations, indexing & slicing
//
// Scans directories, categorizes files by extension, computes
// aggregate statistics, and reactively updates when the target
// directory or filter changes.
//
// Usage:
//   eval examples/file_processor.eval

// ===== Utilities =====

define get_extension = function(filename) {
    define len = filename->length;
    define i = len - 1;
    define result = "";
    while(i >= 0) {
        if(filename->char_at(i) == `integer->char`(46)) {
            result = filename->slice(i, len);
            i = -1;
        } else {
            i = i - 1;
        };
    };
    result;
};

define read_file = function(path) {
    define p = `open-input-file`(path);
    define content = `read-string`(4000000, p);
    `close-input-port`(p);
    content;
};

define count_lines = function(text) {
    `string-fold`(function(ch, n)
        if(ch == `integer->char`(10)) n + 1 else n,
        0, text);
};

define format_size = function(bytes) {
    cond(
        bytes >= 1048576: `number->string`(quotient(bytes, 1048576)) ++ " MB",
        bytes >= 1024:    `number->string`(quotient(bytes, 1024)) ++ " KB",
        else:             `number->string`(bytes) ++ " B"
    );
};

define pad_right = function(str, width) {
    if(str->length >= width) str
    else str ++ " "->repeat(width - str->length);
};

define pad_left = function(str, width) {
    if(str->length >= width) str
    else " "->repeat(width - str->length) ++ str;
};

define is_text_file = function(name) {
    name->ends_with(".eval") || name->ends_with(".py")
    || name->ends_with(".c") || name->ends_with(".h")
    || name->ends_with(".scm") || name->ends_with(".md")
    || name->ends_with(".txt") || name->ends_with(".y")
    || name->ends_with(".sld") || name->ends_with(".stub");
};

// ===== Reactive Configuration =====

define target_dir = Signal(".");
define extension_filter = Signal("");  // empty means all files

// ===== Reactive Processing Pipeline =====

// Step 1: Scan directory, filter out . and .. and subdirectories
define all_files = Computed(function() {
    define dir = target_dir();
    define entries = directory_files(dir);
    entries->filter(function(f)
        f != "." && f != ".."
        && !`file-directory?`(dir ++ "/" ++ f));
});

// Step 2: Apply extension filter
define filtered_files = Computed(function() {
    define ext = extension_filter();
    define files = all_files();
    if(ext == "") files
    else files->filter(function(f) f->ends_with(ext));
});

// Step 3: Compute file details — list of [name, size, extension, lines]
define file_details = Computed(function() {
    define dir = target_dir();
    filtered_files()->map(function(f) {
        define path = dir ++ "/" ++ f;
        define sz = file_size(path);
        define ext = get_extension(f);
        // Count lines for small text files
        define lines = if(sz < 500000 && is_text_file(f)) {
            try count_lines(read_file(path))
            catch(err) 0;
        } else 0;
        [f, sz, ext, lines];
    });
});

// Step 4: Build the full report as a single computed value.
// This avoids diamond-dependency glitches — the effect depends on
// one computed which depends on everything, so it fires exactly once.
define report_data = Computed(function() {
    define dir = target_dir();
    define ext = extension_filter();
    define details = file_details();
    define n = details->length;
    define total_sz = details->fold(function(d, acc) acc + d[1], 0);
    define total_ln = details->fold(function(d, acc) acc + d[3], 0);

    define largest = if(n == 0) false
        else details->drop(1)->fold(function(d, best)
            if(d[1] > best[1]) d else best,
            details->first);

    define most_ln = if(n == 0) false
        else details->drop(1)->fold(function(d, best)
            if(d[3] > best[3]) d else best,
            details->first);

    // Group by extension
    define tbl = `make-hash-table`();
    `for-each`(function(d) {
        define e = d[2];
        define sz = d[1];
        define key = if(e == "") "(no ext)" else e;
        define prev = `hash-table-ref/default`(tbl, key, [0, 0]);
        `hash-table-set!`(tbl, key, [prev[0] + 1, prev[1] + sz]);
    }, details);
    define cats = `hash-table-keys`(tbl)->map(function(key) {
        define entry = `hash-table-ref`(tbl, key);
        [key, entry[0], entry[1]];
    });
    define sorted_cats = `sort`(cats,
        function(a, b) b[1] < a[1]);

    // Return report as a list
    [dir, ext, n, total_sz, total_ln, largest, most_ln, sorted_cats];
});

// ===== Display Effect =====

define separator = "--------------------------------------------";

define report = Effect(function() {
    define data = report_data();
    define dir = data[0];
    define ext = data[1];
    define n = data[2];
    define total_sz = data[3];
    define total_ln = data[4];
    define largest = data[5];
    define most_ln = data[6];
    define cats = data[7];

    display(separator); newline();
    display("  Directory : " ++ dir); newline();
    display("  Filter    : " ++ if(ext == "") "*" else ext); newline();
    display("  Files     : " ++ `number->string`(n)); newline();
    display("  Total size: " ++ format_size(total_sz)); newline();
    display("  Lines     : " ++ `number->string`(total_ln)); newline();

    when(n > 0) {
        display("  Largest   : " ++ largest[0]
            ++ " (" ++ format_size(largest[1]) ++ ")");
        newline();

        define ml_lines = most_ln[3];
        when(ml_lines > 0) {
            display("  Most lines: " ++ most_ln[0]
                ++ " (" ++ `number->string`(ml_lines) ++ " lines)");
            newline();
        };

        when(cats->length > 1) {
            newline();
            display("  By extension:"); newline();
            cats->for_each(function(cat) {
                define ext = pad_right(cat[0], 10);
                define count = pad_left(`number->string`(cat[1]), 4);
                define size = pad_left(format_size(cat[2]), 10);
                display("    " ++ ext ++ count ++ " files  " ++ size);
                newline();
            });
        };
    };

    display(separator); newline();
    newline();
});

// ===== Track changes =====

watch(target_dir, function(new_dir, old_dir) {
    display(">>> Changed directory: " ++ old_dir ++ " -> " ++ new_dir);
    newline();
});

watch(extension_filter, function(new_ext, old_ext) {
    define old_label = if(old_ext == "") "*" else old_ext;
    define new_label = if(new_ext == "") "*" else new_ext;
    display(">>> Changed filter: " ++ old_label ++ " -> " ++ new_label);
    newline();
});

// ===== Demo: scan different directories =====

// Scan examples directory
target_dir->set("examples");

// Filter to just .eval files
extension_filter->set(".eval");

// Scan tests/eval with all files
batch(function() {
    target_dir->set("tests/eval");
    extension_filter->set("");
});

// Filter tests to just .eval
extension_filter->set(".eval");

// Scan source directory
batch(function() {
    target_dir->set("src");
    extension_filter->set("");
});

// Filter to C source files
extension_filter->set(".c");

// Switch to headers
extension_filter->set(".h");

display("Done. Processed multiple directories reactively.");
newline();
