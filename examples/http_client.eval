// http_client.eval — HTTP client helper functions using chibi/net
//
// Provides: http_get, http_post (low-level), HttpClient (OO wrapper, built-in)
//
// Usage (low-level):
//   include("examples/http_client.eval");
//   define r = http_get("127.0.0.1", 8080, "/");
//   display(car(r));        // status code
//   display(car(cdr(r)));   // body
//
// Usage (OO — no include needed, HttpClient is built-in):
//   with(client = HttpClient("127.0.0.1", 8080)) {
//       define r = client->get("/");
//       display(car(r));        // status code
//       display(car(cdr(r)));   // body
//   };

// Find needle in str, return integer index or false.
define string_index = function(str, needle) {
    define cur = string_contains(str, needle);
    if(cur) `string-cursor->index`(str, cur) else false;
};

// Connect to host:port, returns socket fileno
define tcp_connect = function(host, port) {
    define ai = get_address_info(host, `number->string`(port));
    define sock = socket(address_info_family(ai),
                         address_info_socket_type(ai),
                         address_info_protocol(ai));
    connect(sock, address_info_address(ai), address_info_address_length(ai));
    sock;
};

define tcp_send = function(sock, str) {
    send(sock, string_to_utf8(str));
};

define tcp_recv = function(sock, n) {
    define bv = recv(sock, n);
    if(bv == false) "" else utf8_to_string(bv);
};

// Read a complete HTTP response: headers then Content-Length bytes of body.
define parse_response = function(sock) {
    define buf = "";
    define header_end = false;
    while(!header_end) {
        define chunk = tcp_recv(sock, 4096);
        if(chunk == "") return [0, ""];
        buf = buf ++ chunk;
        header_end = string_index(buf, "\r\n\r\n");
    };

    define headers_str = substring(buf, 0, header_end);
    define body_start_data = substring(buf, header_end + 4, `string-length`(buf));

    // Parse status from first line: "HTTP/1.0 200 OK"
    define sp1 = string_index(headers_str, " ");
    define status_str = if(sp1) {
        define rest = substring(headers_str, sp1 + 1, `string-length`(headers_str));
        define sp2 = string_index(rest, " ");
        if(sp2) substring(rest, 0, sp2) else rest;
    } else "0";
    define status = `string->number`(status_str);

    // Find Content-Length
    define content_length = 0;
    define lower_headers = string_downcase_ascii(headers_str);
    define cl_idx = string_index(lower_headers, "content-length: ");
    when(cl_idx) {
        define after_cl = substring(headers_str, cl_idx + 16, `string-length`(headers_str));
        define eol = string_index(after_cl, "\r\n");
        define cl_str = if(eol) substring(after_cl, 0, eol) else after_cl;
        content_length = `string->number`(cl_str);
    };

    // Read remaining body
    define body = body_start_data;
    while(`string-length`(body) < content_length) {
        define chunk = tcp_recv(sock, content_length - `string-length`(body));
        if(chunk == "") return [status, body];
        body = body ++ chunk;
    };

    [status, body];
};

// GET request — returns [status, body]
define http_get = function(host, port, path) {
    define sock = tcp_connect(host, port);
    define request = "GET " ++ path ++ " HTTP/1.0\r\n"
        ++ "Host: " ++ host ++ "\r\n"
        ++ "Connection: close\r\n"
        ++ "\r\n";
    tcp_send(sock, request);
    define result = parse_response(sock);
    close_file_descriptor(sock);
    result;
};

// POST request — returns [status, body]
define http_post = function(host, port, path, body) {
    define sock = tcp_connect(host, port);
    define request = "POST " ++ path ++ " HTTP/1.0\r\n"
        ++ "Host: " ++ host ++ "\r\n"
        ++ "Content-Length: " ++ `number->string`(`string-length`(body)) ++ "\r\n"
        ++ "Content-Type: text/plain\r\n"
        ++ "Connection: close\r\n"
        ++ "\r\n"
        ++ body;
    tcp_send(sock, request);
    define result = parse_response(sock);
    close_file_descriptor(sock);
    result;
};
