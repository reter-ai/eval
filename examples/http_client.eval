// http_client.eval — HTTP client helper functions using chibi/net
//
// Provides: http_get, http_post (low-level), HttpClient (OO wrapper, built-in)
//
// Usage (low-level):
//   include("examples/http_client.eval");
//   define r = http_get("127.0.0.1", 8080, "/");
//   display(r->first);       // status code
//   display(r->ref(1));      // body
//
// Usage (OO — no include needed, HttpClient is built-in):
//   with(client = HttpClient("127.0.0.1", 8080)) {
//       define r = client->get("/");
//       display(r->first);       // status code
//       display(r->ref(1));      // body
//   };

// Connect to host:port, returns socket fileno
define tcp_connect = function(host, port) {
    define ai = get_address_info(host, `number->string`(port));
    define sock = socket(address_info_family(ai),
                         address_info_socket_type(ai),
                         address_info_protocol(ai));
    connect(sock, address_info_address(ai), address_info_address_length(ai));
    sock;
};

define tcp_send = function(sock, str) {
    send(sock, string_to_utf8(str));
};

define tcp_recv = function(sock, n) {
    define bv = recv(sock, n);
    if(bv == false) "" else utf8_to_string(bv);
};

// Read a complete HTTP response: headers then Content-Length bytes of body.
define parse_response = function(sock) {
    define buf = "";
    define header_end = false;
    while(!header_end) {
        define chunk = tcp_recv(sock, 4096);
        if(chunk == "") return [0, ""];
        buf = buf ++ chunk;
        header_end = buf->index_of("\r\n\r\n");
    };

    define headers_str = buf->slice(0, header_end);
    define body_start_data = buf->slice(header_end + 4, buf->length);

    // Parse status from first line: "HTTP/1.0 200 OK"
    define sp1 = headers_str->index_of(" ");
    define status_str = if(sp1) {
        define rest = headers_str->slice(sp1 + 1, headers_str->length);
        define sp2 = rest->index_of(" ");
        if(sp2) rest->slice(0, sp2) else rest;
    } else "0";
    define status = status_str->to_number();

    // Find Content-Length
    define content_length = 0;
    define lower_headers = headers_str->lower();
    define cl_idx = lower_headers->index_of("content-length: ");
    when(cl_idx) {
        define after_cl = headers_str->slice(cl_idx + 16, headers_str->length);
        define eol = after_cl->index_of("\r\n");
        define cl_str = if(eol) after_cl->slice(0, eol) else after_cl;
        content_length = cl_str->to_number();
    };

    // Read remaining body
    define body = body_start_data;
    while(body->length < content_length) {
        define chunk = tcp_recv(sock, content_length - body->length);
        if(chunk == "") return [status, body];
        body = body ++ chunk;
    };

    [status, body];
};

// GET request — returns [status, body]
define http_get = function(host, port, path) {
    define sock = tcp_connect(host, port);
    define request = "GET " ++ path ++ " HTTP/1.0\r\n"
        ++ "Host: " ++ host ++ "\r\n"
        ++ "Connection: close\r\n"
        ++ "\r\n";
    tcp_send(sock, request);
    define result = parse_response(sock);
    close_file_descriptor(sock);
    result;
};

// POST request — returns [status, body]
define http_post = function(host, port, path, body) {
    define sock = tcp_connect(host, port);
    define request = "POST " ++ path ++ " HTTP/1.0\r\n"
        ++ "Host: " ++ host ++ "\r\n"
        ++ "Content-Length: " ++ `number->string`(body->length) ++ "\r\n"
        ++ "Content-Type: text/plain\r\n"
        ++ "Connection: close\r\n"
        ++ "\r\n"
        ++ body;
    tcp_send(sock, request);
    define result = parse_response(sock);
    close_file_descriptor(sock);
    result;
};
