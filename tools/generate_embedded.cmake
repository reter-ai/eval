# generate_embedded.cmake
# Generates eval_embedded_scm.c from all .scm/.sld files under LIB_DIR
# and optionally .eval files under EVAL_LIB_DIR.
#
# Usage: cmake -DLIB_DIR=... [-DEVAL_LIB_DIR=...] -DOUTPUT=... -P generate_embedded.cmake

if(NOT DEFINED LIB_DIR OR NOT DEFINED OUTPUT)
    message(FATAL_ERROR "Usage: cmake -DLIB_DIR=<path> -DOUTPUT=<path> -P generate_embedded.cmake")
endif()

# Collect all .scm and .sld files, excluding test/bench files
file(GLOB_RECURSE ALL_FILES
    "${LIB_DIR}/*.scm"
    "${LIB_DIR}/*.sld"
)

set(SCM_FILES "")
foreach(f ${ALL_FILES})
    get_filename_component(fname "${f}" NAME)
    # Only exclude files ending in -test.scm or -test.sld (not test.scm itself)
    string(REGEX MATCH "-test\\.(scm|sld)$" _is_test "${fname}")
    string(REGEX MATCH "-bench\\.(scm|sld)$" _is_bench "${fname}")
    if(NOT _is_test AND NOT _is_bench)
        list(APPEND SCM_FILES "${f}")
    endif()
endforeach()

# Collect .eval files from EVAL_LIB_DIR if provided
set(EVAL_FILES "")
if(DEFINED EVAL_LIB_DIR)
    file(GLOB_RECURSE EVAL_FILES "${EVAL_LIB_DIR}/*.eval")
endif()

list(SORT SCM_FILES)
list(SORT EVAL_FILES)

# Start generating: write header
file(WRITE "${OUTPUT}" "/* eval_embedded_scm.c -- Auto-generated embedded scheme/eval files */\n")
file(APPEND "${OUTPUT}" "/* DO NOT EDIT -- generated by tools/generate_embedded.cmake */\n\n")
file(APPEND "${OUTPUT}" "#include \"eval_embedded_scm.h\"\n\n")

set(FILE_INDEX 0)
set(ENTRIES "")

# Helper: embed a single file given absolute path, base dir, and path prefix
# We process both lists with the same logic
foreach(f ${SCM_FILES})
    file(RELATIVE_PATH rel "${LIB_DIR}" "${f}")

    # Generate array name from path
    string(REPLACE "/" "_" arr_name "${rel}")
    string(REPLACE "." "_" arr_name "${arr_name}")
    string(REPLACE "-" "_" arr_name "${arr_name}")

    # Read file size
    file(SIZE "${f}" fsize)

    # Read as text, escape for C string, split into 8000-char chunks
    file(READ "${f}" content)
    string(REPLACE "\\" "\\\\" content "${content}")
    string(REPLACE "\"" "\\\"" content "${content}")
    string(REPLACE "\t" "\\t" content "${content}")
    # Replace real newlines with \n escape
    string(REPLACE "\n" "\\n" content "${content}")
    # Remove carriage returns
    string(REPLACE "\r" "" content "${content}")

    # Split into chunks of ~8000 chars to stay well under MSVC's 65535 limit
    # Must avoid splitting escape sequences (\n, \t, \\, \")
    string(LENGTH "${content}" content_len)
    file(APPEND "${OUTPUT}" "static const char scm_${arr_name}[] =\n")
    set(pos 0)
    while(pos LESS content_len)
        math(EXPR remaining "${content_len} - ${pos}")
        if(remaining GREATER 8000)
            set(chunk_len 8000)
            # Check if we're splitting an escape sequence (backslash at end)
            math(EXPR last_char_pos "${pos} + ${chunk_len} - 1")
            string(SUBSTRING "${content}" ${last_char_pos} 1 last_char)
            if(last_char STREQUAL "\\")
                # Back up one char to avoid splitting the escape
                math(EXPR chunk_len "${chunk_len} - 1")
            endif()
        else()
            set(chunk_len ${remaining})
        endif()
        string(SUBSTRING "${content}" ${pos} ${chunk_len} chunk)
        file(APPEND "${OUTPUT}" "\"${chunk}\"\n")
        math(EXPR pos "${pos} + ${chunk_len}")
    endwhile()
    file(APPEND "${OUTPUT}" ";\n\n")

    # Forward-slash path for C string
    string(REPLACE "\\" "/" rel_fwd "${rel}")
    # Size is original file size + 1 for NUL (sizeof includes it since string literal adds NUL)
    list(APPEND ENTRIES "    {\"${rel_fwd}\", scm_${arr_name}, sizeof(scm_${arr_name})}")

    math(EXPR FILE_INDEX "${FILE_INDEX} + 1")
    if(FILE_INDEX MATCHES "^[0-9]*0$")
        message(STATUS "  processed ${FILE_INDEX} files...")
    endif()
endforeach()

# Now embed .eval files (same logic, different base dir)
foreach(f ${EVAL_FILES})
    file(RELATIVE_PATH rel "${EVAL_LIB_DIR}" "${f}")

    # Generate array name with "eval_" prefix to avoid collisions
    string(REPLACE "/" "_" arr_name "eval_${rel}")
    string(REPLACE "." "_" arr_name "${arr_name}")
    string(REPLACE "-" "_" arr_name "${arr_name}")

    file(SIZE "${f}" fsize)

    file(READ "${f}" content)
    string(REPLACE "\\" "\\\\" content "${content}")
    string(REPLACE "\"" "\\\"" content "${content}")
    string(REPLACE "\t" "\\t" content "${content}")
    string(REPLACE "\n" "\\n" content "${content}")
    string(REPLACE "\r" "" content "${content}")

    string(LENGTH "${content}" content_len)
    file(APPEND "${OUTPUT}" "static const char scm_${arr_name}[] =\n")
    set(pos 0)
    while(pos LESS content_len)
        math(EXPR remaining "${content_len} - ${pos}")
        if(remaining GREATER 8000)
            set(chunk_len 8000)
            math(EXPR last_char_pos "${pos} + ${chunk_len} - 1")
            string(SUBSTRING "${content}" ${last_char_pos} 1 last_char)
            if(last_char STREQUAL "\\")
                math(EXPR chunk_len "${chunk_len} - 1")
            endif()
        else()
            set(chunk_len ${remaining})
        endif()
        string(SUBSTRING "${content}" ${pos} ${chunk_len} chunk)
        file(APPEND "${OUTPUT}" "\"${chunk}\"\n")
        math(EXPR pos "${pos} + ${chunk_len}")
    endwhile()
    file(APPEND "${OUTPUT}" ";\n\n")

    # Use "eval/" prefix in the path to distinguish from .scm files
    string(REPLACE "\\" "/" rel_fwd "${rel}")
    list(APPEND ENTRIES "    {\"eval/${rel_fwd}\", scm_${arr_name}, sizeof(scm_${arr_name})}")

    math(EXPR FILE_INDEX "${FILE_INDEX} + 1")
endforeach()

# Generate the table
file(APPEND "${OUTPUT}" "const EmbeddedSchemeFile embedded_scheme_files[] = {\n")
list(JOIN ENTRIES ",\n" ENTRIES_STR)
file(APPEND "${OUTPUT}" "${ENTRIES_STR},\n")
file(APPEND "${OUTPUT}" "    {0, 0, 0}\n")
file(APPEND "${OUTPUT}" "};\n\n")
file(APPEND "${OUTPUT}" "const int embedded_scheme_file_count = ${FILE_INDEX};\n")

message(STATUS "Generated ${OUTPUT} with ${FILE_INDEX} embedded files")
