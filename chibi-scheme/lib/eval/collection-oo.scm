;; eval/collection-oo.scm -- OO methods for lists, vectors, and dicts via __send__
;; Loaded after string-oo.scm. Chains onto previous __send__ dispatch.

;; Helper: join list of strings with separator
(define (__list-join__ lst sep)
  (if (null? lst) ""
      (if (null? (cdr lst)) (car lst)
          (string-concatenate
            (cons (car lst)
                  (let loop ((rest (cdr lst)))
                    (if (null? rest) '()
                        (cons sep (cons (car rest) (loop (cdr rest)))))))))))

;; Helper: apply a list operation on a vector, returning a vector
(define (__vector-via-list__ fn obj)
  (list->vector (fn (vector->list obj))))

;; List dispatch
(define (__list-send__ obj msg)
  (cond
    ;; Properties
    ((eq? msg 'length)     (length obj))
    ((eq? msg 'empty?)     (null? obj))
    ((eq? msg 'first)      (car obj))
    ((eq? msg 'second)     (cadr obj))
    ((eq? msg 'third)      (car (cdr (cdr obj))))
    ((eq? msg 'rest)       (cdr obj))
    ((eq? msg 'last)       (last obj))
    ;; Methods
    ((eq? msg 'ref)        (lambda (i) (ref obj i)))
    ((eq? msg 'slice)      (lambda (start end) (slice obj start end)))
    ((eq? msg 'map)        (lambda (fn) (map fn obj)))
    ((eq? msg 'filter)     (lambda (fn) (filter fn obj)))
    ((eq? msg 'reject)     (lambda (fn) (remove fn obj)))
    ((eq? msg 'fold)       (lambda (fn init) (fold fn init obj)))
    ((eq? msg 'fold_right) (lambda (fn init) (fold-right fn init obj)))
    ((eq? msg 'for_each)   (lambda (fn) (for-each fn obj)))
    ((eq? msg 'flat_map)   (lambda (fn) (append-map fn obj)))
    ((eq? msg 'bind)       (lambda (fn) (append-map fn obj)))
    ((eq? msg 'pure)       (lambda (v) (list v)))
    ((eq? msg 'mappend)    (lambda (other) (append obj other)))
    ((eq? msg 'any)        (lambda (pred) (if (any pred obj) #t #f)))
    ((eq? msg 'every)      (lambda (pred) (if (every pred obj) #t #f)))
    ((eq? msg 'find)       (lambda (pred) (find pred obj)))
    ((eq? msg 'count)      (lambda (pred) (count pred obj)))
    ((eq? msg 'index_of)   (lambda (pred) (list-index pred obj)))
    ((eq? msg 'contains)   (lambda (x) (if (member x obj) #t #f)))
    ((eq? msg 'reverse)    (lambda () (reverse obj)))
    ((eq? msg 'append)     (lambda (other) (append obj other)))
    ((eq? msg 'flatten)    (lambda () (apply append obj)))
    ((eq? msg 'take)       (lambda (n) (take obj n)))
    ((eq? msg 'drop)       (lambda (n) (drop obj n)))
    ((eq? msg 'take_while) (lambda (pred) (take-while pred obj)))
    ((eq? msg 'drop_while) (lambda (pred) (drop-while pred obj)))
    ((eq? msg 'sort)       (lambda (cmp) (sort obj cmp)))
    ((eq? msg 'unique)     (lambda () (delete-duplicates obj)))
    ((eq? msg 'partition)  (lambda (pred)
                             (let-values (((yes no) (partition pred obj)))
                               (list yes no))))
    ((eq? msg 'zip)        (lambda (other) (zip obj other)))
    ((eq? msg 'join)       (lambda (sep) (__list-join__ obj sep)))
    ((eq? msg 'to_vector)  (lambda () (list->vector obj)))
    ((eq? msg 'copy)       (lambda () (list-copy obj)))
    ((eq? msg 'take_right) (lambda (n) (take-right obj n)))
    ((eq? msg 'drop_right) (lambda (n) (drop-right obj n)))
    ((eq? msg 'split_at)   (lambda (n)
                             (let-values (((left right) (split-at obj n)))
                               (list left right))))
    ((eq? msg 'span)       (lambda (pred)
                             (let-values (((head tail) (span pred obj)))
                               (list head tail))))
    ((eq? msg 'filter_map) (lambda (fn) (filter-map fn obj)))
    ((eq? msg 'reduce)     (lambda (fn)
                             (if (null? obj)
                                 (error "reduce on empty list")
                                 (fold fn (car obj) (cdr obj)))))
    ((eq? msg 'reduce_right) (lambda (fn)
                               (if (null? obj)
                                   (error "reduce_right on empty list")
                                   (fold-right fn (last obj)
                                     (reverse (cdr (reverse obj)))))))
    ((eq? msg 'delete)     (lambda (x) (delete x obj)))
    (else (error "unknown list method" msg))))

;; Vector dispatch
(define (__vector-send__ obj msg)
  (cond
    ;; Properties
    ((eq? msg 'length)     (vector-length obj))
    ((eq? msg 'empty?)     (= (vector-length obj) 0))
    ((eq? msg 'first)      (vector-ref obj 0))
    ((eq? msg 'second)     (vector-ref obj 1))
    ((eq? msg 'third)      (vector-ref obj 2))
    ((eq? msg 'last)       (vector-ref obj (- (vector-length obj) 1)))
    ((eq? msg 'rest)       (vector-copy obj 1))
    ;; Methods
    ((eq? msg 'ref)        (lambda (i) (ref obj i)))
    ((eq? msg 'slice)      (lambda (start end) (slice obj start end)))
    ((eq? msg 'map)        (lambda (fn) (vector-map fn obj)))
    ((eq? msg 'for_each)   (lambda (fn) (vector-for-each fn obj)))
    ((eq? msg 'fold)       (lambda (fn init) (fold fn init (vector->list obj))))
    ((eq? msg 'any)        (lambda (pred) (if (any pred (vector->list obj)) #t #f)))
    ((eq? msg 'every)      (lambda (pred) (if (every pred (vector->list obj)) #t #f)))
    ((eq? msg 'find)       (lambda (pred) (find pred (vector->list obj))))
    ((eq? msg 'count)      (lambda (pred) (count pred (vector->list obj))))
    ((eq? msg 'index_of)   (lambda (pred) (list-index pred (vector->list obj))))
    ((eq? msg 'contains)   (lambda (x) (if (member x (vector->list obj)) #t #f)))
    ((eq? msg 'filter)     (lambda (fn) (__vector-via-list__ (lambda (l) (filter fn l)) obj)))
    ((eq? msg 'reject)     (lambda (fn) (__vector-via-list__ (lambda (l) (remove fn l)) obj)))
    ((eq? msg 'reverse)    (lambda () (__vector-via-list__ reverse obj)))
    ((eq? msg 'sort)       (lambda (cmp) (__vector-via-list__ (lambda (l) (sort l cmp)) obj)))
    ((eq? msg 'unique)     (lambda () (__vector-via-list__ delete-duplicates obj)))
    ((eq? msg 'append)     (lambda (other) (vector-append obj other)))
    ((eq? msg 'to_list)    (lambda () (vector->list obj)))
    ((eq? msg 'copy)       (lambda () (vector-copy obj)))
    ((eq? msg 'set)        (lambda (i val) (vector-set! obj i val)))
    (else (error "unknown vector method" msg))))

;; Dict (hash-table) dispatch
(define (__dict-send__ obj msg)
  (cond
    ;; Properties
    ((eq? msg 'length)     (hash-table-size obj))
    ((eq? msg 'size)       (hash-table-size obj))
    ((eq? msg 'empty?)     (= (hash-table-size obj) 0))
    ((eq? msg 'keys)       (hash-table-keys obj))
    ((eq? msg 'values)     (hash-table-values obj))
    ((eq? msg 'entries)    (hash-table->alist obj))
    ;; Methods
    ((eq? msg 'get)        (lambda (k . rest)
                             (hash-table-ref/default obj
                               (if (string? k) (string->symbol k) k)
                               (if (null? rest) #f (car rest)))))
    ((eq? msg 'set)        (lambda (k v)
                             (hash-table-set! obj
                               (if (string? k) (string->symbol k) k) v)))
    ((eq? msg 'delete)     (lambda (k)
                             (hash-table-delete! obj
                               (if (string? k) (string->symbol k) k))))
    ((eq? msg 'has?)       (lambda (k)
                             (hash-table-exists? obj
                               (if (string? k) (string->symbol k) k))))
    ((eq? msg 'to_list)    (lambda () (hash-table->alist obj)))
    ((eq? msg 'map)        (lambda (fn)
                             (__make_eval_dict__
                               (map (lambda (p) (cons (car p) (fn (car p) (cdr p))))
                                    (hash-table->alist obj)))))
    ((eq? msg 'filter)     (lambda (fn)
                             (__make_eval_dict__
                               (filter (lambda (p) (fn (car p) (cdr p)))
                                       (hash-table->alist obj)))))
    ((eq? msg 'reject)     (lambda (fn)
                             (__make_eval_dict__
                               (remove (lambda (p) (fn (car p) (cdr p)))
                                       (hash-table->alist obj)))))
    ((eq? msg 'for_each)   (lambda (fn)
                             (hash-table-walk obj fn)))
    ((eq? msg 'fold)       (lambda (fn init)
                             (hash-table-fold obj fn init)))
    ((eq? msg 'any)        (lambda (fn)
                             (let ((al (hash-table->alist obj)))
                               (let loop ((rest al))
                                 (if (null? rest) #f
                                     (if (fn (caar rest) (cdar rest)) #t
                                         (loop (cdr rest))))))))
    ((eq? msg 'every)      (lambda (fn)
                             (let ((al (hash-table->alist obj)))
                               (let loop ((rest al))
                                 (if (null? rest) #t
                                     (if (fn (caar rest) (cdar rest))
                                         (loop (cdr rest))
                                         #f))))))
    ((eq? msg 'find)       (lambda (fn)
                             (let ((al (hash-table->alist obj)))
                               (let loop ((rest al))
                                 (if (null? rest) #f
                                     (if (fn (caar rest) (cdar rest))
                                         (car rest)
                                         (loop (cdr rest))))))))
    ((eq? msg 'count)      (lambda (fn)
                             (let ((al (hash-table->alist obj)))
                               (let loop ((rest al) (n 0))
                                 (if (null? rest) n
                                     (loop (cdr rest)
                                           (if (fn (caar rest) (cdar rest))
                                               (+ n 1) n)))))))
    ((eq? msg 'merge)      (lambda (other)
                             (let ((ht (__make_eval_dict__ (hash-table->alist obj))))
                               (for-each (lambda (p)
                                           (hash-table-set! ht (car p) (cdr p)))
                                         (hash-table->alist other))
                               ht)))
    ((eq? msg 'copy)       (lambda ()
                             (__make_eval_dict__ (hash-table->alist obj))))
    ((eq? msg 'update)     (lambda (k fn)
                             (let ((sk (if (string? k) (string->symbol k) k)))
                               (hash-table-set! obj sk
                                 (fn (hash-table-ref/default obj sk #f))))))
    ((eq? msg 'merge!)     (lambda (other)
                             (for-each (lambda (p)
                                         (hash-table-set! obj (car p) (cdr p)))
                                       (hash-table->alist other))))
    ((eq? msg 'clear)      (lambda ()
                             (for-each (lambda (k) (hash-table-delete! obj k))
                                       (hash-table-keys obj))))
    ;; Field access fallback: d->name â†’ hash-table lookup
    ((hash-table-exists? obj msg)
     (hash-table-ref obj msg))
    (else #f)))

;; Chain onto previous __send__
(let ((__prev-send__ __send__))
  (set! __send__
    (lambda (obj msg)
      (cond
        ((pair? obj)       (__list-send__ obj msg))
        ((vector? obj)     (__vector-send__ obj msg))
        ((hash-table? obj) (__dict-send__ obj msg))
        (else (__prev-send__ obj msg))))))
