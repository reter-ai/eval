;; eval/string-oo.scm -- OO string methods via __send__ dispatch
;; Loaded after eval_init_all_libs() so (chibi string) functions are available.

;; Helper: split string by substring separator (uses cursors, not integer indices)
(define (__string-split-by str sep)
  (let ((seplen (string-length sep)))
    (if (= seplen 0)
        (map string (string->list str))
        (let ((end (string-cursor-end str)))
          (let loop ((start (string-cursor-start str)) (acc '()))
            (let ((pos (string-contains str sep start)))
              (if pos
                  (loop (string-cursor-forward str pos seplen)
                        (cons (substring-cursor str start pos) acc))
                  (reverse (cons (substring-cursor str start end) acc)))))))))

;; index_of helper: convert cursor to integer index (or return #f)
(define (__string-index-of str needle)
  (let ((pos (string-contains str needle)))
    (if pos (string-cursor->index str pos) #f)))

;; Redefine __send__ with string dispatch (using cond/eq? instead of case)
(define (__send__ obj msg)
  (if (string? obj)
      (cond
        ((eq? msg 'length)     (string-length obj))
        ((eq? msg 'empty?)     (= (string-length obj) 0))
        ((eq? msg 'upper)      (lambda () (string-upcase-ascii obj)))
        ((eq? msg 'lower)      (lambda () (string-downcase-ascii obj)))
        ((eq? msg 'trim)       (lambda () (string-trim obj)))
        ((eq? msg 'trim_start) (lambda () (string-trim-left obj)))
        ((eq? msg 'trim_end)   (lambda () (string-trim-right obj)))
        ((eq? msg 'contains)   (lambda (s) (if (string-contains obj s) #t #f)))
        ((eq? msg 'starts_with) (lambda (s) (string-prefix? s obj)))
        ((eq? msg 'ends_with)  (lambda (s) (string-suffix? s obj)))
        ((eq? msg 'index_of)   (lambda (s) (__string-index-of obj s)))
        ((eq? msg 'replace)    (lambda (old new)
                        (let ((parts (__string-split-by obj old)))
                          (string-concatenate
                            (let loop ((p parts))
                              (if (null? (cdr p))
                                  p
                                  (cons (car p) (cons new (loop (cdr p))))))))))
        ((eq? msg 'split)      (lambda (sep) (__string-split-by obj sep)))
        ((eq? msg 'join)       (lambda (lst)
                        (string-concatenate
                          (let loop ((l lst))
                            (if (null? (cdr l))
                                l
                                (cons (car l) (cons obj (loop (cdr l)))))))))
        ((eq? msg 'reverse)    (lambda () (list->string (reverse (string->list obj)))))
        ((eq? msg 'repeat)     (lambda (n)
                        (let loop ((i 0) (acc ""))
                          (if (>= i n) acc
                              (loop (+ i 1) (string-append acc obj))))))
        ((eq? msg 'chars)      (lambda () (string->list obj)))
        ((eq? msg 'char_at)    (lambda (i) (string-ref obj i)))
        ((eq? msg 'to_number)  (lambda () (string->number obj)))
        ((eq? msg 'to_symbol)  (lambda () (string->symbol obj)))
        ((eq? msg 'slice)      (lambda (start end) (substring obj start end)))
        ((eq? msg 'map)        (lambda (fn) (string-map fn obj)))
        ((eq? msg 'fold)       (lambda (fn init) (string-fold fn init obj)))
        ((eq? msg 'for_each)   (lambda (fn) (string-for-each fn obj)))
        ((eq? msg 'any)        (lambda (pred) (string-any pred obj)))
        ((eq? msg 'every)      (lambda (pred) (string-every pred obj)))
        ((eq? msg 'count)      (lambda (pred) (string-count obj pred)))
        ((eq? msg 'find)       (lambda (pred)
                        (let ((c (string-find obj pred)))
                          (if (string-cursor>=? c (string-cursor-end obj))
                              #f
                              (string-cursor-ref obj c)))))
        ((eq? msg 'copy)       (lambda () (string-copy obj)))
        ((eq? msg 'find_right) (lambda (pred)
                        (let ((c (string-find-right obj pred)))
                          (if (string-cursor<=? c (string-cursor-start obj))
                              #f
                              (string-cursor-ref obj
                                (string-cursor-prev obj c))))))
        ((eq? msg 'skip)       (lambda (pred)
                        (let ((c (string-skip obj pred)))
                          (if (string-cursor>=? c (string-cursor-end obj))
                              #f
                              (string-cursor-ref obj c)))))
        ((eq? msg 'fold_right) (lambda (fn init) (string-fold-right fn init obj)))
        (else (error "unknown string method" msg)))
      (obj msg)))
