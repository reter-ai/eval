test_begin("TaskPool");

// === Basic submit + await ===
{
    with(pool = TaskPool(2));
    define p = pool->submit(function() 42);
    test("basic submit", 42, await(p));
};

// === run() convenience ===
{
    with(pool = TaskPool(2));
    test("run", 100, pool->run(function() 50 + 50));
};

// === Multiple submits ===
{
    with(pool = TaskPool(2));
    define p1 = pool->submit(function() 10);
    define p2 = pool->submit(function() 20);
    define p3 = pool->submit(function() 30);
    test("multi a", 10, await(p1));
    test("multi b", 20, await(p2));
    test("multi c", 30, await(p3));
};

// === map() distributes and collects ===
{
    with(pool = TaskPool(2));
    define results = pool->map([1, 2, 3, 4], function(x) x * x);
    test("map squares", [1, 4, 9, 16], results);
};

// === Error propagation ===
{
    with(pool = TaskPool(2));
    define p = pool->submit(function() error("boom"));
    define caught = try { await(p); } catch(e) "caught";
    test("error propagation", "caught", caught);
};

// === drain() waits for all pending ===
{
    with(pool = TaskPool(2));
    pool->submit(function() 1);
    pool->submit(function() 2);
    pool->submit(function() 3);
    pool->drain();
    test("drain pending", 0, pool->pending_count());
};

// === Closures serialize correctly ===
{
    with(pool = TaskPool(2));
    define base = 1000;
    define add_base = function(x) x + base;
    test("closure submit", 1042, pool->run(function() add_base(42)));
};

// === Multiple tasks on single worker complete (green threads) ===
{
    with(pool = TaskPool(1));
    // All 3 tasks go to the same worker (n=1, round-robin).
    // They run as separate green threads within that worker.
    define p1 = pool->submit(function() { thread_yield(); 10; });
    define p2 = pool->submit(function() { thread_yield(); 20; });
    define p3 = pool->submit(function() { thread_yield(); 30; });
    test("single worker a", 10, await(p1));
    test("single worker b", 20, await(p2));
    test("single worker c", 30, await(p3));
};

// === Tasks access pool channels by name inside workers ===
{
    with(pool = TaskPool(1));
    define ch = pool->channel("__test_ch");
    define pa = pool->submit(function() {
        channel_send(__test_ch, "hello from worker");
        "sent";
    });
    test("worker channel send", "sent", await(pa));
    test("worker channel recv", "hello from worker", ch->recv());
};

// === size property ===
{
    with(pool = TaskPool(3));
    test("size", 3, pool->size);
};

// === Double shutdown is safe ===
{
    define pool = TaskPool(1);
    pool->shutdown();
    pool->shutdown();
    test("double shutdown", true, true);
};

// === RAII via with() ===
define raii_result = with(p = TaskPool(2)) {
    p->run(function() 99);
};
test("RAII with()", 99, raii_result);

// === map with larger workload ===
{
    with(pool = TaskPool(2));
    define results = pool->map([1, 2, 3, 4, 5, 6, 7, 8], function(x) x * 10);
    test("map 8 items", [10, 20, 30, 40, 50, 60, 70, 80], results);
};

// === Computation-heavy tasks ===
{
    with(pool = TaskPool(2));
    define fib = function(n) if(n <= 1) n else fib(n - 1) + fib(n - 2);
    define p1 = pool->submit(function() fib(15));
    define p2 = pool->submit(function() fib(16));
    test("fib 15", 610, await(p1));
    test("fib 16", 987, await(p2));
};

// === Same-worker green threads communicate via channel_recv ===
// This would deadlock if channel_recv wasn't green-thread-aware.
{
    with(pool = TaskPool(1));
    define ch = pool->channel("__sync");
    // Task A blocks on channel_recv, Task B sends â€” both on same worker
    define pa = pool->submit(function() {
        define msg = channel_recv(__sync);
        msg + 100;
    });
    define pb = pool->submit(function() {
        channel_send(__sync, 42);
        "B done";
    });
    test("green recv B", "B done", await(pb));
    test("green recv A", 142, await(pa));
};

// === parallel async: dispatches to OS threads ===
{
    define fib = function(n) if(n <= 1) n else fib(n - 1) + fib(n - 2);
    with(ap = AsyncPool(2));
    define a = parallel async fib(15);
    define b = parallel async fib(16);
    test("parallel async fib15", 610, await(a));
    test("parallel async fib16", 987, await(b));
};

// === async always uses green threads (even with pool set) ===
{
    with(ap = AsyncPool(2));
    test("async green inside AsyncPool", 42, await(async 42));
};

// === Hybrid: async (green) + parallel async (OS) in same scope ===
{
    define fib = function(n) if(n <= 1) n else fib(n - 1) + fib(n - 2);
    with(ap = AsyncPool(2));
    define green = async 1 + 2;              // green thread
    define os1 = parallel async fib(15);     // OS thread
    define os2 = parallel async fib(16);     // OS thread
    test("hybrid green", 3, await(green));
    test("hybrid os1", 610, await(os1));
    test("hybrid os2", 987, await(os2));
};

// === AsyncPool restores pool on close ===
{
    test("pre-AsyncPool no pool", false, get_async_pool());
    {
        with(ap = AsyncPool(2));
        test("inside AsyncPool has pool", true, not(not(get_async_pool())));
    };
    test("post-AsyncPool no pool", false, get_async_pool());
};

// === Green thread fallback (no pool set) ===
{
    test("green thread fallback", 42, await(async 42));
};

// === parallel async without pool errors ===
{
    define caught = try { parallel async 42; } catch(e) "caught";
    test("parallel async no pool", "caught", caught);
};

// === Manual set_async_pool / get_async_pool ===
{
    define pool = TaskPool(2);
    set_async_pool(pool);
    define p = parallel async 100 + 23;
    test("manual parallel dispatch", 123, await(p));
    set_async_pool(false);
    test("manual restore", false, get_async_pool());
    pool->shutdown();
};

// === Error propagation through parallel async ===
{
    with(ap = AsyncPool(2));
    define p = parallel async { error("boom"); };
    define caught = try { await(p); } catch(e) "caught";
    test("parallel async error", "caught", caught);
};

// === Nested AsyncPool restores to outer ===
{
    with(outer = AsyncPool(1));
    define outer_pool = get_async_pool();
    {
        with(inner = AsyncPool(1));
        test("nested inner has pool", true, not(not(get_async_pool())));
    };
    test("nested restores outer", outer_pool, get_async_pool());
};

test_end();
