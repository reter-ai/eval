test_begin("Reactive");

// === Signal basics ===
define s = Signal(0);
test("signal read", 0, s());
s->set(10);
test("signal set", 10, s());
s->set(10);  // same value, no-op
test("signal set same", 10, s());

// update
s->update(function(v) v + 5);
test("signal update", 15, s());

// peek (no tracking)
test("signal peek", 15, s->peek);

// === Type predicates ===
test("signal?", true, signal?(s));
test("signal? not computed", false, computed?(s));
test("signal? not effect", false, effect?(s));

// === Computed basics ===
define a = Signal(2);
define b = Signal(3);
define sum = Computed(function() a() + b());
test("computed initial", 5, sum());

a->set(10);
test("computed after update", 13, sum());

b->set(7);
test("computed after update b", 17, sum());

test("computed?", true, computed?(sum));
test("computed? not signal", false, signal?(sum));

// === Computed caching (lazy, no recompute if clean) ===
define count = Signal(0);
define calls = 0;
define cached = Computed(function() {
    calls = calls + 1;
    count() * 2;
});
test("cached initial", 0, cached());
define c1 = calls;
cached();  // should not recompute
cached();  // should not recompute
test("cached no extra recompute", c1, calls);

count->set(5);
test("cached after update", 10, cached());
test("cached recomputed once", c1 + 1, calls);

// === Computed chain ===
define x = Signal(1);
define doubled = Computed(function() x() * 2);
define quadrupled = Computed(function() doubled() * 2);
test("chain initial", 4, quadrupled());

x->set(3);
test("chain propagated", 12, quadrupled());

// === Effect basics ===
define log = [];
define es = Signal(0);
define eff = Effect(function() {
    define v = es();
    log = cons(v, log);
});
test("effect initial run", [0], log);

es->set(1);
test("effect re-run", [1, 0], log);

es->set(2);
test("effect re-run 2", [2, 1, 0], log);

test("effect?", true, effect?(eff));

// === Effect cleanup ===
define cleanup_log = [];
define cs = Signal(0);
define ceff = Effect(function() {
    define v = cs();
    cleanup_log = cons(`string-append`("run:", `number->string`(v)), cleanup_log);
    function() {
        cleanup_log = cons(`string-append`("cleanup:", `number->string`(v)), cleanup_log);
    };
});
test("cleanup initial", ["run:0"], cleanup_log);

cs->set(1);
// cleanup of previous run should fire, then new run
test("cleanup on re-run",
     ["run:1", "cleanup:0", "run:0"],
     cleanup_log);

// === Dispose stops updates ===
define ds = Signal(0);
define dlog = [];
define deff = Effect(function() {
    dlog = cons(ds(), dlog);
});
test("dispose initial", [0], dlog);

dispose(deff);
ds->set(99);
test("dispose stops updates", [0], dlog);

// === Dispose runs cleanup ===
define ds2 = Signal(0);
define dlog2 = [];
define deff2 = Effect(function() {
    ds2();
    function() { dlog2 = cons("cleaned", dlog2); };
});
dispose(deff2);
test("dispose runs cleanup", ["cleaned"], dlog2);

// === batch: multiple updates, single flush ===
define bs = Signal(0);
define blog = [];
define beff = Effect(function() {
    blog = cons(bs(), blog);
});
// Clear initial run
blog = [];

batch(function() {
    bs->set(1);
    bs->set(2);
    bs->set(3);
});
// Only final value should have triggered
test("batch single flush", [3], blog);

// === Diamond problem ===
//   A
//  / \
// B   C
//  \ /
//   D (effect)
define A = Signal(1);
define B = Computed(function() A() * 2);
define C = Computed(function() A() + 10);
define diamond_log = [];
define D = Effect(function() {
    diamond_log = cons(`list`(B(), C()), diamond_log);
});
// Initial: B=2, C=11
test("diamond initial", [[2, 11]], diamond_log);

diamond_log = [];
A->set(5);
// B=10, C=15 — effect should fire once with consistent values
test("diamond single fire", [[10, 15]], diamond_log);

// === Nested batch ===
define ns = Signal(0);
define nlog = [];
define neff = Effect(function() {
    nlog = cons(ns(), nlog);
});
nlog = [];

batch(function() {
    ns->set(1);
    batch(function() {
        ns->set(2);
        ns->set(3);
    });
    // inner batch should not flush yet
    ns->set(4);
});
// Only outermost batch flushes
test("nested batch", [4], nlog);

// === Auto-tracking: conditional deps ===
define flag = Signal(true);
define left = Signal("L");
define right = Signal("R");
define cond_comp = Computed(function()
    if(flag()) left() else right()
);
test("cond initial", "L", cond_comp());

// Changing right should NOT trigger recompute since flag is true
define cond_calls = 0;
define cond_watch = Computed(function() {
    cond_calls = cond_calls + 1;
    cond_comp();
});
cond_watch();
define cc_before = cond_calls;
right->set("R2");
cond_watch();
test("cond no recompute on unused dep", cc_before, cond_calls);

// Now switch flag — should pick up right
flag->set(false);
test("cond switched", "R2", cond_comp());

// === RAII: with(e = Effect(...)) auto-disposes ===
define ws = Signal(0);
define wlog = [];
with(e = Effect(function() {
    wlog = cons(ws(), wlog);
})) {
    ws->set(1);
};
// After with block, effect is disposed
define wlog_after_with = wlog;
ws->set(99);
test("raii effect disposed", wlog_after_with, wlog);

// === Error in computed: recovery on re-read ===
define err_s = Signal(0);
define err_c = Computed(function() {
    if(err_s() == 0) error("bad value");
    err_s() * 10;
});
define err_result = try { err_c(); } catch(e) "error";
test("computed error", "error", err_result);

err_s->set(5);
test("computed recovery", 50, err_c());

// === Dispose signal clears observers ===
define sig_d = Signal(0);
define sig_log = [];
define sig_eff = Effect(function() {
    sig_log = cons(sig_d(), sig_log);
});
sig_log = [];
dispose(sig_d);
// Signal has no observers now, so setting wouldn't notify
// (but setting a disposed signal still changes its value)

// === Computed peek (read without tracking) ===
define ps = Signal(42);
define pc = Computed(function() ps() + 1);
test("computed peek", 43, pc->peek);

// =============================================
// Extended Reactive Utilities
// =============================================

// === untracked: suppress dependency tracking ===
define ut_a = Signal(1);
define ut_b = Signal(2);
define ut_c = Computed(function() ut_a() + untracked(function() ut_b()));
test("untracked initial", 3, ut_c());

ut_a->set(10);
test("untracked tracks a", 12, ut_c());

// Change b — c should NOT recompute since b was untracked
define ut_calls = 0;
define ut_watch = Computed(function() {
    ut_calls = ut_calls + 1;
    ut_c();
});
ut_watch();
define ut_before = ut_calls;
ut_b->set(100);
ut_watch();
test("untracked ignores b", ut_before, ut_calls);

// But the value read when a changes should reflect current b
ut_a->set(5);
test("untracked reads current b", 105, ut_c());

// === derived: shorthand computed from one signal ===
define dr_count = Signal(0);
define dr_doubled = derived(dr_count, function(v) v * 2);
test("derived initial", 0, dr_doubled());

dr_count->set(5);
test("derived propagation", 10, dr_doubled());

dr_count->set(7);
test("derived propagation 2", 14, dr_doubled());

test("derived is computed", true, computed?(dr_doubled));

// === readonly: read-only view of a signal ===
define ro_inner = Signal(42);
define ro = readonly(ro_inner);
test("readonly read", 42, ro());

ro_inner->set(99);
test("readonly tracks source", 99, ro());

test("readonly peek", 99, ro->peek);

// readonly blocks set
define ro_set_err = try { ro->set(5); } catch(e) "blocked";
test("readonly blocks set", "blocked", ro_set_err);

// readonly blocks update
define ro_upd_err = try { ro->update(function(v) v + 1); } catch(e) "blocked";
test("readonly blocks update", "blocked", ro_upd_err);

// readonly type predicate
test("readonly?", true, readonly?(ro));
test("readonly? not signal", false, readonly?(ro_inner));
test("readonly? not computed", false, readonly?(dr_doubled));

// readonly works as dependency in Computed
define ro_comp = Computed(function() ro() + 1);
test("readonly in computed initial", 100, ro_comp());

ro_inner->set(10);
test("readonly in computed tracks", 11, ro_comp());

// === watch: run fn(new, old) on changes ===
define w_s = Signal("Alice");
define w_log = [];
define w_eff = watch(w_s, function(new_val, old_val) {
    w_log = cons([new_val, old_val], w_log);
});
// Initial run should NOT fire fn
test("watch skips initial", [], w_log);

w_s->set("Bob");
test("watch fires on change", [["Bob", "Alice"]], w_log);

w_s->set("Carol");
test("watch fires again", [["Carol", "Bob"], ["Bob", "Alice"]], w_log);

// Dispose stops watching
dispose(w_eff);
w_s->set("Dave");
test("watch dispose stops", [["Carol", "Bob"], ["Bob", "Alice"]], w_log);

// watch returns an effect
define w_s2 = Signal(0);
define w_eff2 = watch(w_s2, function(n, o) n);
test("watch returns effect", true, effect?(w_eff2));
dispose(w_eff2);

// === on: effect with explicit dependency list ===
define on_a = Signal(1);
define on_b = Signal(2);
define on_c = Signal(100);
define on_log = [];
define on_eff = Effect(function() { on_log = []; });  // clear log
on_log = [];

define on_eff2 = on([on_a, on_b], function(av, bv) {
    // c is read inside but should NOT be tracked
    on_log = cons(av + bv + on_c->peek, on_log);
});
// Initial run
test("on initial", [103], on_log);

on_log = [];
on_a->set(10);
test("on tracks listed dep", [112], on_log);

on_log = [];
on_c->set(999);
// c is not tracked, so on shouldn't fire
test("on ignores unlisted dep", [], on_log);

on_log = [];
on_b->set(5);
test("on tracks second dep", [1014], on_log);
dispose(on_eff2);
dispose(on_eff);

// === reduce: fold over signal changes ===
define red_clicks = Signal(0);
define red_total = reduce(red_clicks, function(acc, v) acc + v, 0);
test("reduce initial", 0, red_total());

red_clicks->set(5);
test("reduce after first", 5, red_total());

red_clicks->set(3);
test("reduce after second", 8, red_total());

red_clicks->set(10);
test("reduce after third", 18, red_total());

// reduce returns a signal
test("reduce is signal", true, signal?(red_total));

// reduce with different fn (max tracker)
define red_vals = Signal(0);
define red_max = reduce(red_vals, function(acc, v)
    if(v > acc) v else acc, 0);
test("reduce max initial", 0, red_max());

red_vals->set(5);
test("reduce max 5", 5, red_max());

red_vals->set(3);
test("reduce max still 5", 5, red_max());

red_vals->set(8);
test("reduce max 8", 8, red_max());

// =============================================
// Phase 2: scope, custom equality, WritableComputed,
//          combine, select, prev, trace
// =============================================

// === scope: reactive ownership scope ===
define sc_log = [];
define sc_s = Signal(0);
define sc_handle = scope(function() {
    define a = Computed(function() sc_s() * 2);
    Effect(function() {
        sc_log = cons(a(), sc_log);
    });
});
test("scope initial effect", [0], sc_log);

sc_s->set(5);
test("scope effect runs", [10, 0], sc_log);

// Dispose the scope — should kill the effect
dispose(sc_handle);
sc_s->set(99);
test("scope dispose stops all", [10, 0], sc_log);

test("scope? predicate", true, scope?(sc_handle));
test("scope? not signal", false, scope?(sc_s));

// scope with `with` RAII
define sc2_log = [];
define sc2_s = Signal(0);
with(h = scope(function() {
    Effect(function() {
        sc2_log = cons(sc2_s(), sc2_log);
    });
})) {
    sc2_s->set(1);
};
// After with, scope is disposed
sc2_s->set(99);
test("scope with RAII", [1, 0], sc2_log);

// Nested scopes — inner dispose doesn't affect outer
define sc3_log = [];
define sc3_s = Signal(0);
define sc3_outer = scope(function() {
    Effect(function() {
        sc3_log = cons(`string-append`("outer:", `number->string`(sc3_s())), sc3_log);
    });
    define inner = scope(function() {
        Effect(function() {
            sc3_log = cons(`string-append`("inner:", `number->string`(sc3_s())), sc3_log);
        });
    });
    dispose(inner);
});
// After inner dispose, only inner effect is gone
sc3_log = [];
sc3_s->set(1);
test("nested scope outer alive", ["outer:1"], sc3_log);
dispose(sc3_outer);

// scope registers signals too
define sc4_disposed = false;
define sc4_handle = scope(function() {
    define s = Signal(42);
});
// Disposing scope should dispose the signal (clear observers)
dispose(sc4_handle);
test("scope disposes signals", true, scope?(sc4_handle));

// === Signal with custom equality ===

// Identity equality — same-content list still triggers
define eq_log = [];
define eq_s = Signal([1, 2, 3], =?);
define eq_eff = Effect(function() {
    eq_log = cons(eq_s(), eq_log);
});
eq_log = [];
eq_s->set([1, 2, 3]);  // different object, same content → triggers with =?
test("signal identity eq triggers", [[1, 2, 3]], eq_log);

// With equal? (default), same content would NOT trigger
define eq2_log = [];
define eq2_s = Signal([1, 2, 3]);
define eq2_eff = Effect(function() {
    eq2_log = cons(eq2_s(), eq2_log);
});
eq2_log = [];
eq2_s->set([1, 2, 3]);  // same content → skipped by default
test("signal default eq skips", [], eq2_log);
dispose(eq_eff);
dispose(eq2_eff);

// Always-notify signal (eq always returns false)
define eq3_count = 0;
define eq3_s = Signal(0, function(a, b) false);
define eq3_eff = Effect(function() {
    eq3_s();
    eq3_count = eq3_count + 1;
});
define eq3_before = eq3_count;
eq3_s->set(0);  // same value, but eq returns false → notify
test("signal always-notify eq", eq3_before + 1, eq3_count);
dispose(eq3_eff);

// Custom eq — update works too
define eq4_s = Signal(10, =?);
eq4_s->update(function(v) v + 5);
test("signal custom eq update", 15, eq4_s());
test("signal custom eq peek", 15, eq4_s->peek);

// === Computed with custom equality ===
define ceq_s = Signal(3.14);
define ceq_calls = 0;
define ceq_rounded = Computed(
    function() {
        ceq_calls = ceq_calls + 1;
        `floor`(ceq_s());
    },
    function(a, b) a == b
);
test("computed custom eq initial", 3, ceq_rounded());
define ceq_before = ceq_calls;

// Change source but floor stays same → downstream should NOT be notified
define ceq_downstream = 0;
define ceq_eff = Effect(function() {
    ceq_rounded();
    ceq_downstream = ceq_downstream + 1;
});
define ceq_ds_before = ceq_downstream;
ceq_s->set(3.99);
// Computed recomputes (floor(3.99)=3), but eq says 3==3 → no downstream
test("computed custom eq no propagate", ceq_ds_before, ceq_downstream);

ceq_s->set(4.5);
// Now floor changes: 4 != 3 → downstream notified
test("computed custom eq propagates", ceq_ds_before + 1, ceq_downstream);
dispose(ceq_eff);

// === WritableComputed: two-way computed ===
define wc_celsius = Signal(0);
define wc_fahrenheit = WritableComputed(
    function() wc_celsius() * 9 / 5 + 32,
    function(f) wc_celsius->set((f - 32) * 5 / 9)
);

test("writable computed read", 32, wc_fahrenheit());

wc_fahrenheit->set(212);
test("writable computed write", 100, wc_celsius());
test("writable computed read after write", 212, wc_fahrenheit());

// update
wc_fahrenheit->update(function(f) f - 180);
test("writable computed update", 32, wc_fahrenheit());

// type predicate
test("writable_computed?", true, writable_computed?(wc_fahrenheit));
test("writable_computed? not computed", false, writable_computed?(ceq_rounded));

// peek, level, id delegate to inner
test("writable computed peek", 32, wc_fahrenheit->peek);

// tracks like a computed
define wc_log = [];
define wc_eff = Effect(function() {
    wc_log = cons(wc_fahrenheit(), wc_log);
});
wc_log = [];
wc_celsius->set(100);
test("writable computed tracks", [212], wc_log);
dispose(wc_eff);

// === combine: merge N signals ===
define cb_x = Signal(1);
define cb_y = Signal(2);
define cb_z = Signal(3);
define cb_sum = combine([cb_x, cb_y, cb_z], function(a, b, c) a + b + c);
test("combine initial", 6, cb_sum());

cb_x->set(10);
test("combine after x change", 15, cb_sum());

cb_z->set(30);
test("combine after z change", 42, cb_sum());

test("combine is computed", true, computed?(cb_sum));

// single source combine
define cb_single = combine([cb_x], function(v) v * 100);
test("combine single", 1000, cb_single());

// === select: fine-grained slice ===
define sel_s = Signal([10, 20, 30]);
define sel_first = select(sel_s, function(lst) car(lst));
define sel_last = select(sel_s, function(lst) car(`reverse`(lst)));
test("select first", 10, sel_first());
test("select last", 30, sel_last());

// Change list but first element stays same → sel_first should not propagate
define sel_count = 0;
define sel_eff = Effect(function() {
    sel_first();
    sel_count = sel_count + 1;
});
define sel_before = sel_count;
sel_s->set([10, 99, 99]);  // first is still 10
test("select no propagate", sel_before, sel_count);

sel_s->set([42, 99, 99]);  // first changes to 42
test("select propagates", sel_before + 1, sel_count);
test("select new value", 42, sel_first());
dispose(sel_eff);

// select with custom eq
define sel2_s = Signal(dict(name: "Alice", age: 30));
define sel2_name = select(sel2_s, function(d) d->name);
test("select dict", "Alice", sel2_name());

// === prev: previous value signal ===
define pv_s = Signal(0);
define pv = prev(pv_s);
test("prev initial default", false, pv());

pv_s->set(1);
test("prev after first", 0, pv());

pv_s->set(5);
test("prev after second", 1, pv());

pv_s->set(10);
test("prev after third", 5, pv());

// prev is readonly
test("prev is readonly", true, readonly?(pv));
define pv_err = try { pv->set(99); } catch(e) "blocked";
test("prev blocks set", "blocked", pv_err);

// prev with custom initial
define pv2_s = Signal("hello");
define pv2 = prev(pv2_s, "none");
test("prev custom initial", "none", pv2());

pv2_s->set("world");
test("prev custom after change", "hello", pv2());

// prev works in computed
define pv3_s = Signal(0);
define pv3 = prev(pv3_s);
define pv3_delta = Computed(function() pv3_s() - (if(pv3() == false) 0 else pv3()));
test("prev in computed initial", 0, pv3_delta());

pv3_s->set(10);
test("prev in computed delta", 10, pv3_delta());

pv3_s->set(15);
test("prev in computed delta 2", 5, pv3_delta());

// === trace: debug logging (functional test — returns source) ===
define tr_s = Signal(0);
define tr_result = trace(tr_s, "test");
test("trace returns source", true, tr_result =? tr_s);

// trace doesn't affect signal behavior
tr_s->set(42);
test("trace source works", 42, tr_s());

test_end();
