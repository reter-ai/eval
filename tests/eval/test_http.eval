test_begin("HTTP Server & Client");

// ===== Client helpers (main context) =====

// Find needle in str, return integer index or false.
define string_index = function(str, needle) {
    define cur = string_contains(str, needle);
    if(cur) `string-cursor->index`(str, cur) else false;
};

define tcp_connect = function(host, port) {
    define ai = get_address_info(host, `number->string`(port));
    define sock = socket(address_info_family(ai),
                         address_info_socket_type(ai),
                         address_info_protocol(ai));
    connect(sock, address_info_address(ai), address_info_address_length(ai));
    sock;
};

define tcp_send = function(sock, str) {
    send(sock, string_to_utf8(str));
};

define tcp_recv = function(sock, n) {
    define bv = recv(sock, n);
    if(bv == false) "" else utf8_to_string(bv);
};

define parse_response = function(sock) {
    define buf = "";
    define header_end = false;
    while(!header_end) {
        define chunk = tcp_recv(sock, 4096);
        if(chunk == "") return [0, ""];
        buf = buf ++ chunk;
        header_end = string_index(buf, "\r\n\r\n");
    };

    define headers_str = substring(buf, 0, header_end);
    define body_start_data = substring(buf, header_end + 4, `string-length`(buf));

    define sp1 = string_index(headers_str, " ");
    define status_str = if(sp1) {
        define rest = substring(headers_str, sp1 + 1, `string-length`(headers_str));
        define sp2 = string_index(rest, " ");
        if(sp2) substring(rest, 0, sp2) else rest;
    } else "0";
    define status = `string->number`(status_str);

    define content_length = 0;
    define lower_headers = string_downcase_ascii(headers_str);
    define cl_idx = string_index(lower_headers, "content-length: ");
    when(cl_idx) {
        define after_cl = substring(headers_str, cl_idx + 16, `string-length`(headers_str));
        define eol = string_index(after_cl, "\r\n");
        define cl_str = if(eol) substring(after_cl, 0, eol) else after_cl;
        content_length = `string->number`(cl_str);
    };

    define body = body_start_data;
    while(`string-length`(body) < content_length) {
        define chunk = tcp_recv(sock, content_length - `string-length`(body));
        if(chunk == "") return [status, body];
        body = body ++ chunk;
    };

    [status, body];
};

define http_get = function(host, port, path) {
    define sock = tcp_connect(host, port);
    define request = "GET " ++ path ++ " HTTP/1.0\r\n"
        ++ "Host: " ++ host ++ "\r\n"
        ++ "Connection: close\r\n"
        ++ "\r\n";
    tcp_send(sock, request);
    define result = parse_response(sock);
    close_file_descriptor(sock);
    result;
};

define http_post = function(host, port, path, body) {
    define sock = tcp_connect(host, port);
    define request = "POST " ++ path ++ " HTTP/1.0\r\n"
        ++ "Host: " ++ host ++ "\r\n"
        ++ "Content-Length: " ++ `number->string`(`string-length`(body)) ++ "\r\n"
        ++ "Content-Type: text/plain\r\n"
        ++ "Connection: close\r\n"
        ++ "\r\n"
        ++ body;
    tcp_send(sock, request);
    define result = parse_response(sock);
    close_file_descriptor(sock);
    result;
};

// ===== Concurrent server in pool worker =====
// The server uses green threads: accept loop spawns a thread per connection.
// accept/send/recv are nonblocking — they yield to the scheduler on WOULDBLOCK.

define PORT = 18080;
define HOST = "127.0.0.1";

define pool = make_pool(1);
define ready_ch = pool_channel(pool, "ready");

define server_code = "
    define port = 18080;
    define max_requests = 6;
    define request_count = 0;
    define accepted = 0;

    define string_index = function(str, needle) {
        define cur = string_contains(str, needle);
        if(cur) `string-cursor->index`(str, cur) else false;
    };

    define tcp_send = function(sock, str) {
        send(sock, string_to_utf8(str));
    };

    define tcp_recv = function(sock, n) {
        define bv = recv(sock, n);
        if(bv == false) \"\" else utf8_to_string(bv);
    };

    define parse_request = function(data) {
        define header_end = string_index(data, \"\\r\\n\\r\\n\");
        define headers_str = if(header_end) substring(data, 0, header_end) else data;
        define body = if(header_end) substring(data, header_end + 4, `string-length`(data)) else \"\";

        define first_line_end = string_index(headers_str, \"\\r\\n\");
        define request_line = if(first_line_end) substring(headers_str, 0, first_line_end) else headers_str;

        define sp1 = string_index(request_line, \" \");
        define method = if(sp1) substring(request_line, 0, sp1) else \"GET\";
        define rest = if(sp1) substring(request_line, sp1 + 1, `string-length`(request_line)) else \"/\";
        define sp2 = string_index(rest, \" \");
        define path = if(sp2) substring(rest, 0, sp2) else rest;

        [method, path, body];
    };

    define send_response = function(conn, status, ctype, body) {
        define status_text = cond(
            status == 200: \"OK\",
            status == 404: \"Not Found\",
            status == 405: \"Method Not Allowed\",
            else: \"Error\"
        );
        define header = \"HTTP/1.0 \" ++ `number->string`(status) ++ \" \" ++ status_text ++ \"\\r\\n\"
            ++ \"Content-Type: \" ++ ctype ++ \"\\r\\n\"
            ++ \"Content-Length: \" ++ `number->string`(`string-length`(body)) ++ \"\\r\\n\"
            ++ \"Connection: close\\r\\n\"
            ++ \"\\r\\n\";
        tcp_send(conn, header ++ body);
    };

    // Connection handler — runs in its own green thread
    define handle_connection = function(conn) {
        try {
            define data = tcp_recv(conn, 4096);
            define parsed = parse_request(data);
            define method = car(parsed);
            define path = car(cdr(parsed));
            define body = car(cdr(cdr(parsed)));

            request_count = request_count + 1;

            cond(
                method == \"GET\" && path == \"/\":
                    send_response(conn, 200, \"text/plain\", \"Welcome to Eval HTTP Server\"),
                method == \"GET\" && path == \"/api/count\":
                    send_response(conn, 200, \"text/plain\", `number->string`(request_count)),
                method == \"GET\" && path == \"/api/stats\": {
                    define json = \"{\\\"requests\\\":\" ++ `number->string`(request_count)
                        ++ \",\\\"last_path\\\":\\\"\" ++ path ++ \"\\\"}\";
                    send_response(conn, 200, \"application/json\", json);
                },
                method == \"POST\" && path == \"/api/echo\":
                    send_response(conn, 200, \"text/plain\", body),
                else:
                    send_response(conn, 404, \"text/plain\", \"Not Found\")
            );

            close_file_descriptor(conn);
        } catch(err) {
            try close_file_descriptor(conn) catch(e) false;
        };

    };

    // Accept loop with green threads
    define ai = get_address_info(\"0.0.0.0\", `number->string`(port));
    define listener = make_listener_socket(ai);
    channel_send(ready, true);

    define threads = [];
    while(accepted < max_requests) {
        define sa = make_sockaddr();
        define conn = accept(listener, sa, 16);
        accepted = accepted + 1;
        // Spawn green thread for each connection
        define t = make_thread(function() handle_connection(conn));
        thread_start(t);
        threads = cons(t, threads);
    };

    // Wait for all handler threads to finish
    `for-each`(thread_join, threads);

    close_file_descriptor(listener);
    \"server done\";
";

define server_future = pool_submit(pool, server_code);

// Wait for server to be ready
channel_recv(ready_ch);

// ===== Client Tests =====

// Test 1: GET /
define r1 = http_get(HOST, PORT, "/");
test("GET / status", 200, car(r1));
test("GET / body", "Welcome to Eval HTTP Server", car(cdr(r1)));

// Test 2: GET /api/count (count = 2 after requests 1 and 2)
define r2 = http_get(HOST, PORT, "/api/count");
test("GET /api/count status", 200, car(r2));
test("GET /api/count body", "2", car(cdr(r2)));

// Test 3: POST /api/echo
define r3 = http_post(HOST, PORT, "/api/echo", "hello world");
test("POST /api/echo status", 200, car(r3));
test("POST /api/echo body", "hello world", car(cdr(r3)));

// Test 4: GET /unknown -> 404
define r4 = http_get(HOST, PORT, "/unknown");
test("GET /unknown 404", 404, car(r4));

// Test 5: GET /api/stats -> JSON
define r5 = http_get(HOST, PORT, "/api/stats");
test("GET /api/stats status", 200, car(r5));
define stats_body = car(cdr(r5));
test("stats has requests", true, string_index(stats_body, "requests") != false);

// Test 6: GET /api/count again -> should be 6 now (6th request)
define r6 = http_get(HOST, PORT, "/api/count");
test("GET /api/count final", "6", car(cdr(r6)));

// Wait for server to finish
define server_result = future_result(server_future);
test("server clean exit", "server done", server_result);

pool_shutdown(pool);

test_end();
